
==================== STG: ====================

$WSCons :: Span %1 -> Spans %1 -> Spans =
    \r [dt_sfRp dt_sfRq]
        case dt_sfRp of dt_sfRr {
        __DEFAULT ->
        case dt_sfRq of dt_sfRs { __DEFAULT -> SCons [dt_sfRr dt_sfRs]; };
        };

sat_sfRx :: Parser () =
    \u []
        let {
          sat_sfRw :: Parser Error () =
              \u []
                  let { sat_sfRv :: Word = CCCS W#! [58##];
                  } in  scan8# sat_sfRv; } in
        let {
          sat_sfRu :: Parser Error () =
              \u []
                  let { sat_sfRt :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfRt;
        } in  >> $fMonadParser sat_sfRu sat_sfRw;

colon_reDh :: Parser () = \u [] token sat_sfRx;

sat_sfRG :: Parser () =
    \u []
        let { sat_sfRD :: Char = CCCS C#! [':'#]; } in
        let { sat_sfRE :: String = CCCS :! [sat_sfRD []]; } in
        let { sat_sfRF :: Expected = CCCS Lit! [sat_sfRE]; } in
        let {
          sat_sfRC :: Parser () =
              \u []
                  let {
                    sat_sfRB :: Parser Error () =
                        \u []
                            let { sat_sfRA :: Word = CCCS W#! [58##];
                            } in  scan8# sat_sfRA; } in
                  let {
                    sat_sfRz :: Parser Error () =
                        \u []
                            let { sat_sfRy :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfRy;
                  } in  >> $fMonadParser sat_sfRz sat_sfRB;
        } in  cut' sat_sfRC sat_sfRF;

colon'_reDi :: Parser () = \u [] token' sat_sfRG;

sat_sfRP :: Parser () =
    \u []
        let { sat_sfRM :: Char = CCCS C#! [';'#]; } in
        let { sat_sfRN :: String = CCCS :! [sat_sfRM []]; } in
        let { sat_sfRO :: Expected = CCCS Lit! [sat_sfRN]; } in
        let {
          sat_sfRL :: Parser () =
              \u []
                  let {
                    sat_sfRK :: Parser Error () =
                        \u []
                            let { sat_sfRJ :: Word = CCCS W#! [59##];
                            } in  scan8# sat_sfRJ; } in
                  let {
                    sat_sfRI :: Parser Error () =
                        \u []
                            let { sat_sfRH :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfRH;
                  } in  >> $fMonadParser sat_sfRI sat_sfRK;
        } in  cut' sat_sfRL sat_sfRO;

semi'_reDk :: Parser () = \u [] token' sat_sfRP;

sat_sfRU :: Parser () =
    \u []
        let {
          sat_sfRT :: Parser Error () =
              \u []
                  let { sat_sfRS :: Word = CCCS W#! [123##];
                  } in  scan8# sat_sfRS; } in
        let {
          sat_sfRR :: Parser Error () =
              \u []
                  let { sat_sfRQ :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfRQ;
        } in  >> $fMonadParser sat_sfRR sat_sfRT;

braceL_reDl :: Parser () = \u [] token sat_sfRU;

sat_sfS3 :: Parser () =
    \u []
        let { sat_sfS0 :: Char = CCCS C#! ['}'#]; } in
        let { sat_sfS1 :: String = CCCS :! [sat_sfS0 []]; } in
        let { sat_sfS2 :: Expected = CCCS Lit! [sat_sfS1]; } in
        let {
          sat_sfRZ :: Parser () =
              \u []
                  let {
                    sat_sfRY :: Parser Error () =
                        \u []
                            let { sat_sfRX :: Word = CCCS W#! [125##];
                            } in  scan8# sat_sfRX; } in
                  let {
                    sat_sfRW :: Parser Error () =
                        \u []
                            let { sat_sfRV :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfRV;
                  } in  >> $fMonadParser sat_sfRW sat_sfRY;
        } in  cut' sat_sfRZ sat_sfS2;

braceR'_reDm :: Parser () = \u [] token' sat_sfS3;

sat_sfS8 :: Parser () =
    \u []
        let {
          sat_sfS7 :: Parser Error () =
              \u []
                  let { sat_sfS6 :: Word = CCCS W#! [61##];
                  } in  scan8# sat_sfS6; } in
        let {
          sat_sfS5 :: Parser Error () =
              \u []
                  let { sat_sfS4 :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfS4;
        } in  >> $fMonadParser sat_sfS5 sat_sfS7;

eq_reDo :: Parser () = \u [] token sat_sfS8;

sat_sfSh :: Parser () =
    \u []
        let { sat_sfSe :: Char = CCCS C#! ['='#]; } in
        let { sat_sfSf :: String = CCCS :! [sat_sfSe []]; } in
        let { sat_sfSg :: Expected = CCCS Lit! [sat_sfSf]; } in
        let {
          sat_sfSd :: Parser () =
              \u []
                  let {
                    sat_sfSc :: Parser Error () =
                        \u []
                            let { sat_sfSb :: Word = CCCS W#! [61##];
                            } in  scan8# sat_sfSb; } in
                  let {
                    sat_sfSa :: Parser Error () =
                        \u []
                            let { sat_sfS9 :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfS9;
                  } in  >> $fMonadParser sat_sfSa sat_sfSc;
        } in  cut' sat_sfSd sat_sfSg;

eq'_reDp :: Parser () = \u [] token' sat_sfSh;

sat_sfSq :: Parser () =
    \u []
        let { sat_sfSn :: Char = CCCS C#! [')'#]; } in
        let { sat_sfSo :: String = CCCS :! [sat_sfSn []]; } in
        let { sat_sfSp :: Expected = CCCS Lit! [sat_sfSo]; } in
        let {
          sat_sfSm :: Parser () =
              \u []
                  let {
                    sat_sfSl :: Parser Error () =
                        \u []
                            let { sat_sfSk :: Word = CCCS W#! [41##];
                            } in  scan8# sat_sfSk; } in
                  let {
                    sat_sfSj :: Parser Error () =
                        \u []
                            let { sat_sfSi :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfSi;
                  } in  >> $fMonadParser sat_sfSj sat_sfSl;
        } in  cut' sat_sfSm sat_sfSp;

parR'_reDq :: Parser () = \u [] token' sat_sfSq;

sat_sfSW :: Parser () =
    \u []
        case pure $fApplicativeParser () of nt_sfSr {
        __DEFAULT ->
        case pure $fApplicativeParser () of nt1_sfSs {
        __DEFAULT ->
        case empty of rule_sfSt {
        __DEFAULT ->
        let {
          sat_sfSV :: Parser Error () =
              \u []
                  let {
                    sat_sfSU :: Word8 -> Parser Error () =
                        \r [c_sfSw]
                            case c_sfSw of c1_sfSx {
                            W8# _ ->
                            let {
                              sat_sfSA :: Word8 =
                                  \u []
                                      let { sat_sfSz :: Integer = CCCS IS! [45#];
                                      } in  fromInteger $fNumWord8 sat_sfSz;
                            } in 
                              case == $fEqWord8 c1_sfSx sat_sfSA of {
                                False ->
                                    let {
                                      sat_sfSD :: Word8 =
                                          \u []
                                              let { sat_sfSC :: Integer = CCCS IS! [226#];
                                              } in  fromInteger $fNumWord8 sat_sfSC;
                                    } in 
                                      case == $fEqWord8 c1_sfSx sat_sfSD of {
                                        False ->
                                            let {
                                              sat_sfSG :: Parser Error () =
                                                  \u []
                                                      let { sat_sfSF :: Int = CCCS I#! [1#];
                                                      } in  setBack# sat_sfSF;
                                            } in  >> $fMonadParser sat_sfSG rule_sfSt;
                                        True ->
                                            let {
                                              sat_sfSO :: Parser Error () =
                                                  \u []
                                                      let {
                                                        sat_sfSN :: Parser Error () =
                                                            \u []
                                                                let {
                                                                  sat_sfSM :: Int = CCCS I#! [1#];
                                                                } in  setBack# sat_sfSM;
                                                      } in 
                                                        >> $fMonadParser sat_sfSN rule_sfSt; } in
                                            let {
                                              sat_sfSL :: Parser Error () =
                                                  \u []
                                                      let {
                                                        sat_sfSK :: Parser Error () =
                                                            \u []
                                                                let {
                                                                  sat_sfSJ :: Word =
                                                                      CCCS W#! [37510##];
                                                                } in  scan16# sat_sfSJ; } in
                                                      let {
                                                        sat_sfSI :: Parser Error () =
                                                            \u []
                                                                let {
                                                                  sat_sfSH :: Int = CCCS I#! [1#];
                                                                } in  ensureBytes# sat_sfSH;
                                                      } in  >> $fMonadParser sat_sfSI sat_sfSK;
                                            } in  branch sat_sfSL nt_sfSr sat_sfSO;
                                      };
                                True ->
                                    let {
                                      sat_sfST :: Parser Error () =
                                          \u []
                                              let {
                                                sat_sfSS :: Parser Error () =
                                                    \u []
                                                        let { sat_sfSR :: Int = CCCS I#! [1#];
                                                        } in  setBack# sat_sfSR;
                                              } in  >> $fMonadParser sat_sfSS rule_sfSt; } in
                                    let {
                                      sat_sfSQ :: Parser Error () =
                                          \u []
                                              let { sat_sfSP :: Word = CCCS W#! [62##];
                                              } in  scan8# sat_sfSP;
                                    } in  branch sat_sfSQ nt1_sfSs sat_sfST;
                              };
                            };
                  } in  >>= $fMonadParser scanAny8# sat_sfSU; } in
        let {
          sat_sfSv :: Parser Error () =
              \u []
                  let { sat_sfSu :: Int = CCCS I#! [2#]; } in  ensureBytes# sat_sfSu;
        } in  branch sat_sfSv sat_sfSV rule_sfSt;
        };
        };
        };

arrow_reDr :: Parser () = \u [] token sat_sfSW;

$trModule1_rfxX :: Addr# = "main"#;

$trModule2_rfRb :: TrName =
    CCS_DONT_CARE TrNameS! [$trModule1_rfxX];

$trModule3_rfRc :: Addr# = "Parser"#;

$trModule4_rfRd :: TrName =
    CCS_DONT_CARE TrNameS! [$trModule3_rfRc];

$trModule :: Module =
    CCS_DONT_CARE Module! [$trModule2_rfRb $trModule4_rfRd];

$krep_rfRe :: KindRep =
    CCS_DONT_CARE KindRepTyConApp! [$tcSpan []];

$tcSpans1_rfRf :: Addr# = "Spans"#;

$tcSpans2_rfRg :: TrName = CCS_DONT_CARE TrNameS! [$tcSpans1_rfRf];

$tcSpans :: TyCon =
    CCS_DONT_CARE TyCon! [18428678705515623441##
                          9965618688747535943##
                          $trModule
                          $tcSpans2_rfRg
                          0#
                          krep$*];

$krep1_rfRh :: KindRep =
    CCS_DONT_CARE KindRepTyConApp! [$tcSpans []];

$tc'SNil1_rfRi :: Addr# = "'SNil"#;

$tc'SNil2_rfRj :: TrName = CCS_DONT_CARE TrNameS! [$tc'SNil1_rfRi];

$tc'SNil :: TyCon =
    CCS_DONT_CARE TyCon! [5346395866764986261##
                          3849862329354185328##
                          $trModule
                          $tc'SNil2_rfRj
                          0#
                          $krep1_rfRh];

$krep2_rfRk :: KindRep =
    CCS_DONT_CARE KindRepFun! [$krep1_rfRh $krep1_rfRh];

$krep3_rfRl :: KindRep =
    CCS_DONT_CARE KindRepFun! [$krep_rfRe $krep2_rfRk];

$tc'SCons1_rfRm :: Addr# = "'SCons"#;

$tc'SCons2_rfRn :: TrName =
    CCS_DONT_CARE TrNameS! [$tc'SCons1_rfRm];

$tc'SCons :: TyCon =
    CCS_DONT_CARE TyCon! [11131910094377521450##
                          17943850743096129046##
                          $trModule
                          $tc'SCons2_rfRn
                          0#
                          $krep3_rfRl];

scanIdent_reDt :: Parser () =
    \u [] >> $fMonadParser identStartChar manyIdentChars;

isKeyword_reDs :: Span -> Parser () =
    \r [span_sfSX]
        case span_sfSX of span1_sfSY {
        Span _ _ ->
        let {
          sat_sfTE :: Parser Error () =
              \u []
                  let {
                    sat_sfTD :: Parser Error () =
                        \u []
                            case pure $fApplicativeParser () of nt_sfT1 {
                            __DEFAULT ->
                            case pure $fApplicativeParser () of nt1_sfT2 {
                            __DEFAULT ->
                            case pure $fApplicativeParser () of nt2_sfT3 {
                            __DEFAULT ->
                            case empty of rule_sfT4 {
                            __DEFAULT ->
                            let {
                              sat_sfTC :: Parser Error () =
                                  \u []
                                      let {
                                        sat_sfTB :: Word8 -> Parser Error () =
                                            \r [c_sfT7]
                                                case c_sfT7 of c1_sfT8 {
                                                W8# _ ->
                                                let {
                                                  sat_sfTb :: Word8 =
                                                      \u []
                                                          let {
                                                            sat_sfTa :: Integer = CCCS IS! [85#];
                                                          } in  fromInteger $fNumWord8 sat_sfTa;
                                                } in 
                                                  case == $fEqWord8 c1_sfT8 sat_sfTb of {
                                                    False ->
                                                        let {
                                                          sat_sfTe :: Word8 =
                                                              \u []
                                                                  let {
                                                                    sat_sfTd :: Integer =
                                                                        CCCS IS! [108#];
                                                                  } in 
                                                                    fromInteger $fNumWord8 sat_sfTd;
                                                        } in 
                                                          case == $fEqWord8 c1_sfT8 sat_sfTe of {
                                                            False ->
                                                                let {
                                                                  sat_sfTh :: Word8 =
                                                                      \u []
                                                                          let {
                                                                            sat_sfTg :: Integer =
                                                                                CCCS IS! [206#];
                                                                          } in 
                                                                            fromInteger
                                                                                $fNumWord8 sat_sfTg;
                                                                } in 
                                                                  case
                                                                      == $fEqWord8 c1_sfT8 sat_sfTh
                                                                  of
                                                                  { False ->
                                                                        let {
                                                                          sat_sfTk
                                                                            :: Parser Error () =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sfTj
                                                                                      :: Int =
                                                                                        CCCS I#! [1#];
                                                                                  } in 
                                                                                    setBack#
                                                                                        sat_sfTj;
                                                                        } in 
                                                                          >>  $fMonadParser
                                                                              sat_sfTk
                                                                              rule_sfT4;
                                                                    True ->
                                                                        let {
                                                                          sat_sfTs
                                                                            :: Parser Error () =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sfTr
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sfTq
                                                                                                :: Int =
                                                                                                  CCCS I#! [1#];
                                                                                            } in 
                                                                                              setBack#
                                                                                                  sat_sfTq;
                                                                                  } in 
                                                                                    >>  $fMonadParser
                                                                                        sat_sfTr
                                                                                        rule_sfT4; } in
                                                                        let {
                                                                          sat_sfTp
                                                                            :: Parser Error () =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sfTo
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sfTn
                                                                                                :: Word =
                                                                                                  CCCS W#! [187##];
                                                                                            } in 
                                                                                              scan8#
                                                                                                  sat_sfTn; } in
                                                                                  let {
                                                                                    sat_sfTm
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sfTl
                                                                                                :: Int =
                                                                                                  CCCS I#! [1#];
                                                                                            } in 
                                                                                              ensureBytes#
                                                                                                  sat_sfTl;
                                                                                  } in 
                                                                                    >>  $fMonadParser
                                                                                        sat_sfTm
                                                                                        sat_sfTo;
                                                                        } in 
                                                                          branch
                                                                              sat_sfTp
                                                                              nt1_sfT2
                                                                              sat_sfTs;
                                                                  };
                                                            True ->
                                                                let {
                                                                  sat_sfTA :: Parser Error () =
                                                                      \u []
                                                                          let {
                                                                            sat_sfTz
                                                                              :: Parser Error () =
                                                                                \u []
                                                                                    let {
                                                                                      sat_sfTy
                                                                                        :: Int =
                                                                                          CCCS I#! [1#];
                                                                                    } in 
                                                                                      setBack#
                                                                                          sat_sfTy;
                                                                          } in 
                                                                            >>  $fMonadParser
                                                                                sat_sfTz
                                                                                rule_sfT4; } in
                                                                let {
                                                                  sat_sfTx :: Parser Error () =
                                                                      \u []
                                                                          let {
                                                                            sat_sfTw
                                                                              :: Parser Error () =
                                                                                \u []
                                                                                    let {
                                                                                      sat_sfTv
                                                                                        :: Word =
                                                                                          CCCS W#! [29797##];
                                                                                    } in 
                                                                                      scan16#
                                                                                          sat_sfTv; } in
                                                                          let {
                                                                            sat_sfTu
                                                                              :: Parser Error () =
                                                                                \u []
                                                                                    let {
                                                                                      sat_sfTt
                                                                                        :: Int =
                                                                                          CCCS I#! [2#];
                                                                                    } in 
                                                                                      ensureBytes#
                                                                                          sat_sfTt;
                                                                          } in 
                                                                            >>  $fMonadParser
                                                                                sat_sfTu
                                                                                sat_sfTw;
                                                                } in 
                                                                  branch sat_sfTx nt2_sfT3 sat_sfTA;
                                                          };
                                                    True -> nt_sfT1;
                                                  };
                                                };
                                      } in  >>= $fMonadParser scanAny8# sat_sfTB; } in
                            let {
                              sat_sfT6 :: Parser Error () =
                                  \u []
                                      let { sat_sfT5 :: Int = CCCS I#! [1#];
                                      } in  ensureBytes# sat_sfT5;
                            } in  branch sat_sfT6 sat_sfTC rule_sfT4;
                            };
                            };
                            };
                            };
                  } in  >> $fMonadParser sat_sfTD eof;
        } in  inSpan span1_sfSY sat_sfTE;
        };

Rec {
sat_sfTV :: Parser Error Spans =
    \u [] pure $fApplicativeParser SNil;

sat_sfTU :: Parser Error Spans =
    \u []
        let {
          sat_sfTT :: Parser Error Spans =
              \u []
                  let {
                    sat_sfTS :: () -> Span -> Parser Error Spans =
                        \r [ds_sfTF x_sfTG]
                            case ds_sfTF of {
                            () ->
                            case x_sfTG of x1_sfTI {
                            Span _ _ ->
                            let {
                              sat_sfTR :: Parser Error Spans =
                                  \u []
                                      let {
                                        sat_sfTQ :: Parser Error Spans =
                                            \u []
                                                let {
                                                  sat_sfTP :: Spans -> Spans =
                                                      \r [ds2_sfTN]
                                                          case ds2_sfTN of dt_sfTO {
                                                          __DEFAULT -> SCons [x1_sfTI dt_sfTO];
                                                          };
                                                } in  <$> $fFunctorParser sat_sfTP manyIdents_reDH;
                                      } in  >> $fMonadParser ws sat_sfTQ; } in
                            let {
                              sat_sfTM :: Parser Error () =
                                  \u []
                                      let {
                                        sat_sfTL :: Parser Error () = \u [] isKeyword_reDs x1_sfTI;
                                      } in  fails sat_sfTL;
                            } in  >> $fMonadParser sat_sfTM sat_sfTR;
                            };
                            };
                  } in  spanned scanIdent_reDt sat_sfTS;
        } in  >> $fMonadParser lvl sat_sfTT;

manyIdents_reDH :: Parser Spans = \u [] <|> sat_sfTU sat_sfTV;
end Rec }

Rec {
sat_sfZu :: Parser Error Tm =
    \u []
        let {
          sat_sfZr :: Expected =
              \u []
                  let { sat_sfZq :: String = \u [] unpackCString# "let-definition"#;
                  } in  $fIsStringExpected sat_sfZq; } in
        let { sat_sfZs :: [Expected] = CCCS :! [sat_sfZr []]; } in
        let {
          sat_sfZn :: [Char] = \u [] unpackCString# "ambda expression"#; } in
        let { sat_sfZm :: Char = CCCS C#! ['l'#]; } in
        let { sat_sfZo :: String = CCCS :! [sat_sfZm sat_sfZn]; } in
        let { sat_sfZp :: Expected = CCCS Msg! [sat_sfZo]; } in
        let { sat_sfZt :: [Expected] = CCCS :! [sat_sfZp sat_sfZs]; } in
        let {
          sat_sfZl :: Parser Tm =
              \u []
                  let {
                    sat_sfZk :: Pos -> Parser Error Tm =
                        \r [l_sfXs]
                            case l_sfXs of nt_sfXt {
                            I# _ ->
                            let {
                              sat_sfYn :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sfYm :: Pos -> Parser Error Tm =
                                            \r [r_sfXI]
                                                case r_sfXI of {
                                                I# _ ->
                                                let {
                                                  sat_sfYl :: Parser Error Tm =
                                                      \u []
                                                          case nt_sfXt of {
                                                          I# ipv2_sfXM ->
                                                          let {
                                                            sat_sfYk :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sfYh :: [Char] =
                                                                          \u []
                                                                              unpackCString#
                                                                                  "dentifier"#; } in
                                                                    let {
                                                                      sat_sfYg :: Char =
                                                                          CCCS C#! ['i'#]; } in
                                                                    let {
                                                                      sat_sfYi :: String =
                                                                          CCCS :! [sat_sfYg
                                                                                   sat_sfYh]; } in
                                                                    let {
                                                                      sat_sfYj :: Expected =
                                                                          CCCS Msg! [sat_sfYi]; } in
                                                                    let {
                                                                      sat_sfYf :: Parser Tm =
                                                                          \u []
                                                                              let {
                                                                                sat_sfYe
                                                                                  :: ()
                                                                                     -> Span
                                                                                     -> Parser
                                                                                          Error Tm =
                                                                                    \r [ds_sfXN
                                                                                        x_sfXO]
                                                                                        case
                                                                                            ds_sfXN
                                                                                        of
                                                                                        {
                                                                                        () ->
                                                                                        case
                                                                                            x_sfXO
                                                                                        of
                                                                                        x1_sfXQ
                                                                                        {
                                                                                        Span _ _ ->
                                                                                        let {
                                                                                          sat_sfYd
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 Tm =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfYc
                                                                                                      :: Parser
                                                                                                           Error
                                                                                                           Tm =
                                                                                                        \u []
                                                                                                            let {
                                                                                                              sat_sfYb
                                                                                                                :: UMaybe
                                                                                                                     Tm
                                                                                                                   -> Parser
                                                                                                                        Error
                                                                                                                        Tm =
                                                                                                                  \r [a_sfXX]
                                                                                                                      case
                                                                                                                          a_sfXX
                                                                                                                      of
                                                                                                                      a1_sfXY
                                                                                                                      {
                                                                                                                      UMaybe# _ ->
                                                                                                                      let {
                                                                                                                        sat_sfYa
                                                                                                                          :: Parser
                                                                                                                               Error
                                                                                                                               Tm =
                                                                                                                            \u []
                                                                                                                                let {
                                                                                                                                  sat_sfY9
                                                                                                                                    :: Tm
                                                                                                                                       -> Parser
                                                                                                                                            Error
                                                                                                                                            Tm =
                                                                                                                                      \r [t_sfY0]
                                                                                                                                          case
                                                                                                                                              t_sfY0
                                                                                                                                          of
                                                                                                                                          t1_sfY1
                                                                                                                                          {
                                                                                                                                          __DEFAULT ->
                                                                                                                                          let {
                                                                                                                                            sat_sfY8
                                                                                                                                              :: Parser
                                                                                                                                                   Error
                                                                                                                                                   Tm =
                                                                                                                                                \u []
                                                                                                                                                    let {
                                                                                                                                                      sat_sfY7
                                                                                                                                                        :: Tm
                                                                                                                                                           -> Parser
                                                                                                                                                                Error
                                                                                                                                                                Tm =
                                                                                                                                                          \r [u_sfY2]
                                                                                                                                                              case
                                                                                                                                                                  u_sfY2
                                                                                                                                                              of
                                                                                                                                                              u1_sfY3
                                                                                                                                                              {
                                                                                                                                                              __DEFAULT ->
                                                                                                                                                              let {
                                                                                                                                                                sat_sfY5
                                                                                                                                                                  :: Pos =
                                                                                                                                                                    CCCS I#! [ipv2_sfXM]; } in
                                                                                                                                                              let {
                                                                                                                                                                sat_sfY6
                                                                                                                                                                  :: Tm =
                                                                                                                                                                    CCCS Let! [sat_sfY5
                                                                                                                                                                               x1_sfXQ
                                                                                                                                                                               a1_sfXY
                                                                                                                                                                               t1_sfY1
                                                                                                                                                                               u1_sfY3]; } in
                                                                                                                                                              let {
                                                                                                                                                                sat_sfY4
                                                                                                                                                                  :: Tm
                                                                                                                                                                     -> Parser
                                                                                                                                                                          Error
                                                                                                                                                                          Tm =
                                                                                                                                                                    \u []
                                                                                                                                                                        pure
                                                                                                                                                                            $fApplicativeParser;
                                                                                                                                                              } in 
                                                                                                                                                                $   sat_sfY4
                                                                                                                                                                    sat_sfY6;
                                                                                                                                                              };
                                                                                                                                                    } in 
                                                                                                                                                      >>= $fMonadParser
                                                                                                                                                          tm'_reDQ
                                                                                                                                                          sat_sfY7;
                                                                                                                                          } in 
                                                                                                                                            >>  $fMonadParser
                                                                                                                                                semi'_reDk
                                                                                                                                                sat_sfY8;
                                                                                                                                          };
                                                                                                                                } in 
                                                                                                                                  >>= $fMonadParser
                                                                                                                                      tm'_reDQ
                                                                                                                                      sat_sfY9;
                                                                                                                      } in 
                                                                                                                        >>  $fMonadParser
                                                                                                                            eq'_reDp
                                                                                                                            sat_sfYa;
                                                                                                                      }; } in
                                                                                                            let {
                                                                                                              sat_sfXW
                                                                                                                :: Parser
                                                                                                                     Error
                                                                                                                     Tm =
                                                                                                                  \u []
                                                                                                                      let {
                                                                                                                        sat_sfXV
                                                                                                                          :: Parser
                                                                                                                               Error
                                                                                                                               () =
                                                                                                                            \u []
                                                                                                                                notFollowedBy
                                                                                                                                    colon_reDh
                                                                                                                                    eq_reDo;
                                                                                                                      } in 
                                                                                                                        *>  $fApplicativeParser
                                                                                                                            sat_sfXV
                                                                                                                            tm'_reDQ;
                                                                                                            } in 
                                                                                                              uoptioned
                                                                                                                  sat_sfXW
                                                                                                                  sat_sfYb;
                                                                                                  } in 
                                                                                                    >>  $fMonadParser
                                                                                                        ws
                                                                                                        sat_sfYc; } in
                                                                                        let {
                                                                                          sat_sfXU
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 () =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfXT
                                                                                                      :: Parser
                                                                                                           Error
                                                                                                           () =
                                                                                                        \u []
                                                                                                            isKeyword_reDs
                                                                                                                x1_sfXQ;
                                                                                                  } in 
                                                                                                    fails
                                                                                                        sat_sfXT;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              sat_sfXU
                                                                                              sat_sfYd;
                                                                                        };
                                                                                        };
                                                                              } in 
                                                                                spanned
                                                                                    scanIdent_reDt
                                                                                    sat_sfYe;
                                                                    } in  cut' sat_sfYf sat_sfYj;
                                                          } in  >> $fMonadParser lvl' sat_sfYk;
                                                          };
                                                } in  >> $fMonadParser ws sat_sfYl;
                                                };
                                      } in  >>= $fMonadParser getPos sat_sfYm; } in
                            let {
                              sat_sfXH :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sfXG :: Parser Error Tm =
                                            \u []
                                                let {
                                                  sat_sfXF :: Pos -> Parser Error Tm =
                                                      \r [r_sfXv]
                                                          case r_sfXv of nt1_sfXw {
                                                          I# _ ->
                                                          let {
                                                            sat_sfXE :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sfXD :: Tm =
                                                                          \u []
                                                                              case nt_sfXt of {
                                                                              I# dt1_sfXz ->
                                                                              case nt1_sfXw of {
                                                                              I# dt3_sfXB ->
                                                                              let {
                                                                                sat_sfXC :: Span =
                                                                                    CCCS Span! [dt1_sfXz
                                                                                                dt3_sfXB];
                                                                              } in  Var [sat_sfXC];
                                                                              };
                                                                              };
                                                                    } in  goApp_reDC sat_sfXD;
                                                          } in  >> $fMonadParser ws sat_sfXE;
                                                          };
                                                } in  >>= $fMonadParser getPos sat_sfXF;
                                      } in  >> $fMonadParser manyIdentChars sat_sfXG;
                            } in 
                              case branch identChar sat_sfXH sat_sfYn of nt1_sfYo {
                              __DEFAULT ->
                              let { sat_sfYp :: Parser Error Tm = \u [] lam'_reDN nt_sfXt;
                              } in 
                                case >> $fMonadParser ws sat_sfYp of nt2_sfYq {
                                __DEFAULT ->
                                let {
                                  sat_sfYJ :: Parser Error Tm =
                                      \u []
                                          let {
                                            sat_sfYI :: Pos -> Parser Error Tm =
                                                \r [r_sfYE]
                                                    case r_sfYE of {
                                                    I# _ ->
                                                    let {
                                                      sat_sfYH :: Parser Error Tm =
                                                          \u [] lam'_reDN nt_sfXt;
                                                    } in  >> $fMonadParser ws sat_sfYH;
                                                    };
                                          } in  >>= $fMonadParser getPos sat_sfYI; } in
                                let {
                                  sat_sfYD :: Parser Error Tm =
                                      \u []
                                          let {
                                            sat_sfYC :: Parser Error Tm =
                                                \u []
                                                    let {
                                                      sat_sfYB :: Pos -> Parser Error Tm =
                                                          \r [r_sfYr]
                                                              case r_sfYr of nt3_sfYs {
                                                              I# _ ->
                                                              let {
                                                                sat_sfYA :: Parser Error Tm =
                                                                    \u []
                                                                        let {
                                                                          sat_sfYz :: Tm =
                                                                              \u []
                                                                                  case nt_sfXt of {
                                                                                  I# dt1_sfYv ->
                                                                                  case nt3_sfYs of {
                                                                                  I# dt3_sfYx ->
                                                                                  let {
                                                                                    sat_sfYy
                                                                                      :: Span =
                                                                                        CCCS Span! [dt1_sfYv
                                                                                                    dt3_sfYx];
                                                                                  } in 
                                                                                    Var [sat_sfYy];
                                                                                  };
                                                                                  };
                                                                        } in  goApp_reDC sat_sfYz;
                                                              } in  >> $fMonadParser ws sat_sfYA;
                                                              };
                                                    } in  >>= $fMonadParser getPos sat_sfYB;
                                          } in  >> $fMonadParser manyIdentChars sat_sfYC;
                                } in 
                                  case branch identChar sat_sfYD sat_sfYJ of nt3_sfYK {
                                  __DEFAULT ->
                                  case >> $fMonadParser ws pi'_reDJ of nt4_sfYL {
                                  __DEFAULT ->
                                  let {
                                    sat_sfZj :: Parser Error Tm =
                                        \u []
                                            let {
                                              sat_sfZi :: Word8 -> Parser Error Tm =
                                                  \r [c_sfYO]
                                                      case c_sfYO of c1_sfYP {
                                                      W8# _ ->
                                                      let {
                                                        sat_sfYS :: Word8 =
                                                            \u []
                                                                let {
                                                                  sat_sfYR :: Integer =
                                                                      CCCS IS! [92#];
                                                                } in 
                                                                  fromInteger $fNumWord8 sat_sfYR;
                                                      } in 
                                                        case == $fEqWord8 c1_sfYP sat_sfYS of {
                                                          False ->
                                                              let {
                                                                sat_sfYV :: Word8 =
                                                                    \u []
                                                                        let {
                                                                          sat_sfYU :: Integer =
                                                                              CCCS IS! [108#];
                                                                        } in 
                                                                          fromInteger
                                                                              $fNumWord8 sat_sfYU;
                                                              } in 
                                                                case
                                                                    == $fEqWord8 c1_sfYP sat_sfYV
                                                                of
                                                                { False ->
                                                                      let {
                                                                        sat_sfYY :: Word8 =
                                                                            \u []
                                                                                let {
                                                                                  sat_sfYX
                                                                                    :: Integer =
                                                                                      CCCS IS! [206#];
                                                                                } in 
                                                                                  fromInteger
                                                                                      $fNumWord8
                                                                                      sat_sfYX;
                                                                      } in 
                                                                        case
                                                                            ==  $fEqWord8
                                                                                c1_sfYP
                                                                                sat_sfYY
                                                                        of
                                                                        { False ->
                                                                              let {
                                                                                sat_sfZ1
                                                                                  :: Parser
                                                                                       Error () =
                                                                                    \u []
                                                                                        let {
                                                                                          sat_sfZ0
                                                                                            :: Int =
                                                                                              CCCS I#! [1#];
                                                                                        } in 
                                                                                          setBack#
                                                                                              sat_sfZ0;
                                                                              } in 
                                                                                >>  $fMonadParser
                                                                                    sat_sfZ1
                                                                                    nt4_sfYL;
                                                                          True ->
                                                                              let {
                                                                                sat_sfZ9
                                                                                  :: Parser
                                                                                       Error Tm =
                                                                                    \u []
                                                                                        let {
                                                                                          sat_sfZ8
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 () =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfZ7
                                                                                                      :: Int =
                                                                                                        CCCS I#! [1#];
                                                                                                  } in 
                                                                                                    setBack#
                                                                                                        sat_sfZ7;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              sat_sfZ8
                                                                                              nt4_sfYL; } in
                                                                              let {
                                                                                sat_sfZ6
                                                                                  :: Parser
                                                                                       Error () =
                                                                                    \u []
                                                                                        let {
                                                                                          sat_sfZ5
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 () =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfZ4
                                                                                                      :: Word =
                                                                                                        CCCS W#! [187##];
                                                                                                  } in 
                                                                                                    scan8#
                                                                                                        sat_sfZ4; } in
                                                                                        let {
                                                                                          sat_sfZ3
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 () =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfZ2
                                                                                                      :: Int =
                                                                                                        CCCS I#! [1#];
                                                                                                  } in 
                                                                                                    ensureBytes#
                                                                                                        sat_sfZ2;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              sat_sfZ3
                                                                                              sat_sfZ5;
                                                                              } in 
                                                                                branch
                                                                                    sat_sfZ6
                                                                                    nt3_sfYK
                                                                                    sat_sfZ9;
                                                                        };
                                                                  True ->
                                                                      let {
                                                                        sat_sfZh
                                                                          :: Parser Error Tm =
                                                                            \u []
                                                                                let {
                                                                                  sat_sfZg
                                                                                    :: Parser
                                                                                         Error () =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sfZf
                                                                                              :: Int =
                                                                                                CCCS I#! [1#];
                                                                                          } in 
                                                                                            setBack#
                                                                                                sat_sfZf;
                                                                                } in 
                                                                                  >>  $fMonadParser
                                                                                      sat_sfZg
                                                                                      nt4_sfYL; } in
                                                                      let {
                                                                        sat_sfZe
                                                                          :: Parser Error () =
                                                                            \u []
                                                                                let {
                                                                                  sat_sfZd
                                                                                    :: Parser
                                                                                         Error () =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sfZc
                                                                                              :: Word =
                                                                                                CCCS W#! [29797##];
                                                                                          } in 
                                                                                            scan16#
                                                                                                sat_sfZc; } in
                                                                                let {
                                                                                  sat_sfZb
                                                                                    :: Parser
                                                                                         Error () =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sfZa
                                                                                              :: Int =
                                                                                                CCCS I#! [2#];
                                                                                          } in 
                                                                                            ensureBytes#
                                                                                                sat_sfZa;
                                                                                } in 
                                                                                  >>  $fMonadParser
                                                                                      sat_sfZb
                                                                                      sat_sfZd;
                                                                      } in 
                                                                        branch
                                                                            sat_sfZe
                                                                            nt1_sfYo
                                                                            sat_sfZh;
                                                                };
                                                          True -> nt2_sfYq;
                                                        };
                                                      };
                                            } in  >>= $fMonadParser scanAny8# sat_sfZi; } in
                                  let {
                                    sat_sfYN :: Parser Error () =
                                        \u []
                                            let { sat_sfYM :: Int = CCCS I#! [1#];
                                            } in  ensureBytes# sat_sfYM;
                                  } in  branch sat_sfYN sat_sfZj nt4_sfYL;
                                  };
                                  };
                                };
                              };
                            };
                  } in  >>= $fMonadParser getPos sat_sfZk;
        } in  cut sat_sfZl sat_sfZt;

sat_sg0w :: Pos -> Parser Error Tm =
    \r [pos_sfZv]
        case pos_sfZv of nt_sfZw {
        I# ipv_sfZx ->
        let {
          sat_sg0v :: Parser Error Tm =
              \u []
                  let {
                    sat_sfZE :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfZD :: Tm -> Tm =
                                  \r [ds_sfZy]
                                      case $bNoName $bExpl of dt_sfZz {
                                      ArgInfo# _ ->
                                      case ds_sfZy of dt1_sfZB {
                                      __DEFAULT ->
                                      let { sat_sfZC :: Pos = CCCS I#! [ipv_sfZx];
                                      } in  Lam [sat_sfZC $bDontBind dt_sfZz $bUNothing dt1_sfZB];
                                      };
                                      };
                            } in  <$> $fFunctorParser sat_sfZD goLam_reDM;
                  } in 
                    case >> $fMonadParser ws sat_sfZE of nt1_sfZF {
                    __DEFAULT ->
                    case >> $fMonadParser ws tm'_reDQ of nt2_sfZG {
                    __DEFAULT ->
                    case goLamParL_reDL nt_sfZw of nt3_sfZH {
                    __DEFAULT ->
                    case goLamBraceL_reDK nt_sfZw of nt4_sfZI {
                    __DEFAULT ->
                    let {
                      sat_sg08 :: Parser Error Tm =
                          \u []
                              let {
                                sat_sg07 :: Parser Error Tm =
                                    \u []
                                        let {
                                          sat_sg04 :: [Char] =
                                              \u [] unpackCString# "dentifier"#; } in
                                        let { sat_sg03 :: Char = CCCS C#! ['i'#]; } in
                                        let { sat_sg05 :: String = CCCS :! [sat_sg03 sat_sg04]; } in
                                        let { sat_sg06 :: Expected = CCCS Msg! [sat_sg05]; } in
                                        let {
                                          sat_sg02 :: Parser Tm =
                                              \u []
                                                  let {
                                                    sat_sg01 :: () -> Span -> Parser Error Tm =
                                                        \r [ds_sfZJ x_sfZK]
                                                            case ds_sfZJ of {
                                                            () ->
                                                            case x_sfZK of x1_sfZM {
                                                            Span _ _ ->
                                                            let {
                                                              sat_sg00 :: Parser Error Tm =
                                                                  \u []
                                                                      let {
                                                                        sat_sfZZ
                                                                          :: Parser Error Tm =
                                                                            \u []
                                                                                let {
                                                                                  sat_sfZY
                                                                                    :: Tm -> Tm =
                                                                                      \r [ds2_sfZR]
                                                                                          case
                                                                                              $bBind
                                                                                                  x1_sfZM
                                                                                          of
                                                                                          dt_sfZS
                                                                                          {
                                                                                          Bind# _ ->
                                                                                          case
                                                                                              $bNoName
                                                                                                  $bExpl
                                                                                          of
                                                                                          dt1_sfZU
                                                                                          {
                                                                                          ArgInfo# _ ->
                                                                                          case
                                                                                              ds2_sfZR
                                                                                          of
                                                                                          dt2_sfZW
                                                                                          {
                                                                                          __DEFAULT ->
                                                                                          let {
                                                                                            sat_sfZX
                                                                                              :: Pos =
                                                                                                CCCS I#! [ipv_sfZx];
                                                                                          } in 
                                                                                            Lam [sat_sfZX
                                                                                                 dt_sfZS
                                                                                                 dt1_sfZU
                                                                                                 $bUNothing
                                                                                                 dt2_sfZW];
                                                                                          };
                                                                                          };
                                                                                          };
                                                                                } in 
                                                                                  <$> $fFunctorParser
                                                                                      sat_sfZY
                                                                                      goLam_reDM;
                                                                      } in 
                                                                        >>  $fMonadParser
                                                                            ws
                                                                            sat_sfZZ; } in
                                                            let {
                                                              sat_sfZQ :: Parser Error () =
                                                                  \u []
                                                                      let {
                                                                        sat_sfZP
                                                                          :: Parser Error () =
                                                                            \u []
                                                                                isKeyword_reDs
                                                                                    x1_sfZM;
                                                                      } in  fails sat_sfZP;
                                                            } in 
                                                              >> $fMonadParser sat_sfZQ sat_sg00;
                                                            };
                                                            };
                                                  } in  spanned scanIdent_reDt sat_sg01;
                                        } in  cut' sat_sg02 sat_sg06;
                              } in  >> $fMonadParser lvl' sat_sg07;
                    } in 
                      case >> $fMonadParser ws sat_sg08 of nt5_sg09 {
                      __DEFAULT ->
                      let {
                        sat_sg0u :: Parser Error Tm =
                            \u []
                                let {
                                  sat_sg0t :: Word8 -> Parser Error Tm =
                                      \r [c_sg0c]
                                          case c_sg0c of c1_sg0d {
                                          W8# _ ->
                                          let {
                                            sat_sg0g :: Word8 =
                                                \u []
                                                    let { sat_sg0f :: Integer = CCCS IS! [40#];
                                                    } in  fromInteger $fNumWord8 sat_sg0f;
                                          } in 
                                            case == $fEqWord8 c1_sg0d sat_sg0g of {
                                              False ->
                                                  let {
                                                    sat_sg0j :: Word8 =
                                                        \u []
                                                            let {
                                                              sat_sg0i :: Integer = CCCS IS! [46#];
                                                            } in  fromInteger $fNumWord8 sat_sg0i;
                                                  } in 
                                                    case == $fEqWord8 c1_sg0d sat_sg0j of {
                                                      False ->
                                                          let {
                                                            sat_sg0m :: Word8 =
                                                                \u []
                                                                    let {
                                                                      sat_sg0l :: Integer =
                                                                          CCCS IS! [95#];
                                                                    } in 
                                                                      fromInteger
                                                                          $fNumWord8 sat_sg0l;
                                                          } in 
                                                            case == $fEqWord8 c1_sg0d sat_sg0m of {
                                                              False ->
                                                                  let {
                                                                    sat_sg0p :: Word8 =
                                                                        \u []
                                                                            let {
                                                                              sat_sg0o :: Integer =
                                                                                  CCCS IS! [123#];
                                                                            } in 
                                                                              fromInteger
                                                                                  $fNumWord8
                                                                                  sat_sg0o;
                                                                  } in 
                                                                    case
                                                                        ==  $fEqWord8
                                                                            c1_sg0d
                                                                            sat_sg0p
                                                                    of
                                                                    { False ->
                                                                          let {
                                                                            sat_sg0s
                                                                              :: Parser Error () =
                                                                                \u []
                                                                                    let {
                                                                                      sat_sg0r
                                                                                        :: Int =
                                                                                          CCCS I#! [1#];
                                                                                    } in 
                                                                                      setBack#
                                                                                          sat_sg0r;
                                                                          } in 
                                                                            >>  $fMonadParser
                                                                                sat_sg0s
                                                                                nt5_sg09;
                                                                      True -> nt4_sfZI;
                                                                    };
                                                              True -> nt1_sfZF;
                                                            };
                                                      True -> nt2_sfZG;
                                                    };
                                              True -> nt3_sfZH;
                                            };
                                          };
                                } in  >>= $fMonadParser scanAny8# sat_sg0t; } in
                      let {
                        sat_sg0b :: Parser Error () =
                            \u []
                                let { sat_sg0a :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sg0a;
                      } in  branch sat_sg0b sat_sg0u nt5_sg09;
                      };
                    };
                    };
                    };
                    };
        } in  >> $fMonadParser lvl' sat_sg0v;
        };

sat_sg2A :: Pos -> Parser Error Tm =
    \r [l_sg0x]
        case l_sg0x of nt_sg0y {
        I# ipv_sg0z ->
        let {
          sat_sg0W :: Parser Error Tm =
              \u []
                  let {
                    sat_sg0V :: Pos -> Parser Error Tm =
                        \r [r_sg0O]
                            case r_sg0O of {
                            I# _ ->
                            let {
                              sat_sg0U :: Parser Error Tm =
                                  \u []
                                      let { sat_sg0S :: Pos = CCCS I#! [ipv_sg0z]; } in
                                      let { sat_sg0T :: Tm = CCCS U! [sat_sg0S]; } in
                                      let {
                                        sat_sg0R :: Tm -> Parser Error Tm =
                                            \u [] pure $fApplicativeParser;
                                      } in  $ sat_sg0R sat_sg0T;
                            } in  >> $fMonadParser ws sat_sg0U;
                            };
                  } in  >>= $fMonadParser getPos sat_sg0V; } in
        let {
          sat_sg0N :: Parser Error Tm =
              \u []
                  let {
                    sat_sg0M :: Parser Error Tm =
                        \u []
                            let {
                              sat_sg0L :: Pos -> Parser Error Tm =
                                  \r [r_sg0A]
                                      case r_sg0A of nt1_sg0B {
                                      I# _ ->
                                      let {
                                        sat_sg0K :: Parser Error Tm =
                                            \u []
                                                let {
                                                  sat_sg0J :: Tm =
                                                      \u []
                                                          case nt_sg0y of {
                                                          I# dt1_sg0F ->
                                                          case nt1_sg0B of {
                                                          I# dt3_sg0H ->
                                                          let {
                                                            sat_sg0I :: Span =
                                                                CCCS Span! [dt1_sg0F dt3_sg0H];
                                                          } in  Var [sat_sg0I];
                                                          };
                                                          }; } in
                                                let {
                                                  sat_sg0D :: Tm -> Parser Error Tm =
                                                      \u [] pure $fApplicativeParser;
                                                } in  $ sat_sg0D sat_sg0J;
                                      } in  >> $fMonadParser ws sat_sg0K;
                                      };
                            } in  >>= $fMonadParser getPos sat_sg0L;
                  } in  >> $fMonadParser manyIdentChars sat_sg0M;
        } in 
          case branch identChar sat_sg0N sat_sg0W of nt1_sg0X {
          __DEFAULT ->
          let {
            sat_sg1g :: Parser Error Tm =
                \u []
                    let {
                      sat_sg1f :: Pos -> Parser Error Tm =
                          \r [r_sg1c] case r_sg1c of { I# _ -> >> $fMonadParser ws empty; };
                    } in  >>= $fMonadParser getPos sat_sg1f; } in
          let {
            sat_sg1b :: Parser Error Tm =
                \u []
                    let {
                      sat_sg1a :: Parser Error Tm =
                          \u []
                              let {
                                sat_sg19 :: Pos -> Parser Error Tm =
                                    \r [r_sg0Y]
                                        case r_sg0Y of nt2_sg0Z {
                                        I# _ ->
                                        let {
                                          sat_sg18 :: Parser Error Tm =
                                              \u []
                                                  let {
                                                    sat_sg17 :: Tm =
                                                        \u []
                                                            case nt_sg0y of {
                                                            I# dt1_sg13 ->
                                                            case nt2_sg0Z of {
                                                            I# dt3_sg15 ->
                                                            let {
                                                              sat_sg16 :: Span =
                                                                  CCCS Span! [dt1_sg13 dt3_sg15];
                                                            } in  Var [sat_sg16];
                                                            };
                                                            }; } in
                                                  let {
                                                    sat_sg11 :: Tm -> Parser Error Tm =
                                                        \u [] pure $fApplicativeParser;
                                                  } in  $ sat_sg11 sat_sg17;
                                        } in  >> $fMonadParser ws sat_sg18;
                                        };
                              } in  >>= $fMonadParser getPos sat_sg19;
                    } in  >> $fMonadParser manyIdentChars sat_sg1a;
          } in 
            case branch identChar sat_sg1b sat_sg1g of nt2_sg1h {
            __DEFAULT ->
            let {
              sat_sg1A :: Parser Error Tm =
                  \u []
                      let {
                        sat_sg1z :: Pos -> Parser Error Tm =
                            \r [r_sg1w] case r_sg1w of { I# _ -> >> $fMonadParser ws empty; };
                      } in  >>= $fMonadParser getPos sat_sg1z; } in
            let {
              sat_sg1v :: Parser Error Tm =
                  \u []
                      let {
                        sat_sg1u :: Parser Error Tm =
                            \u []
                                let {
                                  sat_sg1t :: Pos -> Parser Error Tm =
                                      \r [r_sg1i]
                                          case r_sg1i of nt3_sg1j {
                                          I# _ ->
                                          let {
                                            sat_sg1s :: Parser Error Tm =
                                                \u []
                                                    let {
                                                      sat_sg1r :: Tm =
                                                          \u []
                                                              case nt_sg0y of {
                                                              I# dt1_sg1n ->
                                                              case nt3_sg1j of {
                                                              I# dt3_sg1p ->
                                                              let {
                                                                sat_sg1q :: Span =
                                                                    CCCS Span! [dt1_sg1n dt3_sg1p];
                                                              } in  Var [sat_sg1q];
                                                              };
                                                              }; } in
                                                    let {
                                                      sat_sg1l :: Tm -> Parser Error Tm =
                                                          \u [] pure $fApplicativeParser;
                                                    } in  $ sat_sg1l sat_sg1r;
                                          } in  >> $fMonadParser ws sat_sg1s;
                                          };
                                } in  >>= $fMonadParser getPos sat_sg1t;
                      } in  >> $fMonadParser manyIdentChars sat_sg1u;
            } in 
              case branch identChar sat_sg1v sat_sg1A of nt3_sg1B {
              __DEFAULT ->
              let {
                sat_sg1E :: Parser Error Tm =
                    \u []
                        let { sat_sg1C :: Pos = CCCS I#! [ipv_sg0z]; } in
                        let { sat_sg1D :: Tm = CCCS Hole! [sat_sg1C];
                        } in  pure $fApplicativeParser sat_sg1D;
              } in 
                case >> $fMonadParser ws sat_sg1E of nt4_sg1F {
                __DEFAULT ->
                let {
                  sat_sg1G :: Parser Error Tm =
                      \u [] *> $fApplicativeParser ws tm'_reDQ;
                } in 
                  case <* $fApplicativeParser sat_sg1G parR'_reDq of nt5_sg1H {
                  __DEFAULT ->
                  let {
                    sat_sg1U :: Parser Error Tm =
                        \u []
                            let {
                              sat_sg1T :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sg1S :: Pos -> Parser Error Tm =
                                            \r [r_sg1I]
                                                case r_sg1I of nt6_sg1J {
                                                I# _ ->
                                                let {
                                                  sat_sg1R :: Parser Error Tm =
                                                      \u []
                                                          let {
                                                            sat_sg1Q :: Tm =
                                                                \u []
                                                                    case nt_sg0y of {
                                                                    I# dt1_sg1M ->
                                                                    case nt6_sg1J of {
                                                                    I# dt3_sg1O ->
                                                                    let {
                                                                      sat_sg1P :: Span =
                                                                          CCCS Span! [dt1_sg1M
                                                                                      dt3_sg1O];
                                                                    } in  Var [sat_sg1P];
                                                                    };
                                                                    };
                                                          } in  pure $fApplicativeParser sat_sg1Q;
                                                } in  >> $fMonadParser ws sat_sg1R;
                                                };
                                      } in  >>= $fMonadParser getPos sat_sg1S;
                            } in  >> $fMonadParser manyIdentChars sat_sg1T;
                  } in 
                    case >> $fMonadParser identStartChar sat_sg1U of nt6_sg1V {
                    __DEFAULT ->
                    let {
                      sat_sg2z :: Parser Error Tm =
                          \u []
                              let {
                                sat_sg2y :: Word8 -> Parser Error Tm =
                                    \r [c_sg1Y]
                                        case c_sg1Y of c1_sg1Z {
                                        W8# _ ->
                                        let {
                                          sat_sg22 :: Word8 =
                                              \u []
                                                  let { sat_sg21 :: Integer = CCCS IS! [40#];
                                                  } in  fromInteger $fNumWord8 sat_sg21;
                                        } in 
                                          case == $fEqWord8 c1_sg1Z sat_sg22 of {
                                            False ->
                                                let {
                                                  sat_sg25 :: Word8 =
                                                      \u []
                                                          let {
                                                            sat_sg24 :: Integer = CCCS IS! [85#];
                                                          } in  fromInteger $fNumWord8 sat_sg24;
                                                } in 
                                                  case == $fEqWord8 c1_sg1Z sat_sg25 of {
                                                    False ->
                                                        let {
                                                          sat_sg28 :: Word8 =
                                                              \u []
                                                                  let {
                                                                    sat_sg27 :: Integer =
                                                                        CCCS IS! [95#];
                                                                  } in 
                                                                    fromInteger $fNumWord8 sat_sg27;
                                                        } in 
                                                          case == $fEqWord8 c1_sg1Z sat_sg28 of {
                                                            False ->
                                                                let {
                                                                  sat_sg2b :: Word8 =
                                                                      \u []
                                                                          let {
                                                                            sat_sg2a :: Integer =
                                                                                CCCS IS! [108#];
                                                                          } in 
                                                                            fromInteger
                                                                                $fNumWord8 sat_sg2a;
                                                                } in 
                                                                  case
                                                                      == $fEqWord8 c1_sg1Z sat_sg2b
                                                                  of
                                                                  { False ->
                                                                        let {
                                                                          sat_sg2e :: Word8 =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sg2d
                                                                                      :: Integer =
                                                                                        CCCS IS! [206#];
                                                                                  } in 
                                                                                    fromInteger
                                                                                        $fNumWord8
                                                                                        sat_sg2d;
                                                                        } in 
                                                                          case
                                                                              ==  $fEqWord8
                                                                                  c1_sg1Z
                                                                                  sat_sg2e
                                                                          of
                                                                          { False ->
                                                                                let {
                                                                                  sat_sg2h
                                                                                    :: Parser
                                                                                         Error () =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sg2g
                                                                                              :: Int =
                                                                                                CCCS I#! [1#];
                                                                                          } in 
                                                                                            setBack#
                                                                                                sat_sg2g;
                                                                                } in 
                                                                                  >>  $fMonadParser
                                                                                      sat_sg2h
                                                                                      nt6_sg1V;
                                                                            True ->
                                                                                let {
                                                                                  sat_sg2p
                                                                                    :: Parser
                                                                                         Error Tm =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sg2o
                                                                                              :: Parser
                                                                                                   Error
                                                                                                   () =
                                                                                                \u []
                                                                                                    let {
                                                                                                      sat_sg2n
                                                                                                        :: Int =
                                                                                                          CCCS I#! [1#];
                                                                                                    } in 
                                                                                                      setBack#
                                                                                                          sat_sg2n;
                                                                                          } in 
                                                                                            >>  $fMonadParser
                                                                                                sat_sg2o
                                                                                                nt6_sg1V; } in
                                                                                let {
                                                                                  sat_sg2m
                                                                                    :: Parser
                                                                                         Error () =
                                                                                      \u []
                                                                                          let {
                                                                                            sat_sg2l
                                                                                              :: Parser
                                                                                                   Error
                                                                                                   () =
                                                                                                \u []
                                                                                                    let {
                                                                                                      sat_sg2k
                                                                                                        :: Word =
                                                                                                          CCCS W#! [187##];
                                                                                                    } in 
                                                                                                      scan8#
                                                                                                          sat_sg2k; } in
                                                                                          let {
                                                                                            sat_sg2j
                                                                                              :: Parser
                                                                                                   Error
                                                                                                   () =
                                                                                                \u []
                                                                                                    let {
                                                                                                      sat_sg2i
                                                                                                        :: Int =
                                                                                                          CCCS I#! [1#];
                                                                                                    } in 
                                                                                                      ensureBytes#
                                                                                                          sat_sg2i;
                                                                                          } in 
                                                                                            >>  $fMonadParser
                                                                                                sat_sg2j
                                                                                                sat_sg2l;
                                                                                } in 
                                                                                  branch
                                                                                      sat_sg2m
                                                                                      nt2_sg1h
                                                                                      sat_sg2p;
                                                                          };
                                                                    True ->
                                                                        let {
                                                                          sat_sg2x
                                                                            :: Parser Error Tm =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sg2w
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sg2v
                                                                                                :: Int =
                                                                                                  CCCS I#! [1#];
                                                                                            } in 
                                                                                              setBack#
                                                                                                  sat_sg2v;
                                                                                  } in 
                                                                                    >>  $fMonadParser
                                                                                        sat_sg2w
                                                                                        nt6_sg1V; } in
                                                                        let {
                                                                          sat_sg2u
                                                                            :: Parser Error () =
                                                                              \u []
                                                                                  let {
                                                                                    sat_sg2t
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sg2s
                                                                                                :: Word =
                                                                                                  CCCS W#! [29797##];
                                                                                            } in 
                                                                                              scan16#
                                                                                                  sat_sg2s; } in
                                                                                  let {
                                                                                    sat_sg2r
                                                                                      :: Parser
                                                                                           Error
                                                                                           () =
                                                                                        \u []
                                                                                            let {
                                                                                              sat_sg2q
                                                                                                :: Int =
                                                                                                  CCCS I#! [2#];
                                                                                            } in 
                                                                                              ensureBytes#
                                                                                                  sat_sg2q;
                                                                                  } in 
                                                                                    >>  $fMonadParser
                                                                                        sat_sg2r
                                                                                        sat_sg2t;
                                                                        } in 
                                                                          branch
                                                                              sat_sg2u
                                                                              nt3_sg1B
                                                                              sat_sg2x;
                                                                  };
                                                            True -> nt4_sg1F;
                                                          };
                                                    True -> nt1_sg0X;
                                                  };
                                            True -> nt5_sg1H;
                                          };
                                        };
                              } in  >>= $fMonadParser scanAny8# sat_sg2y; } in
                    let {
                      sat_sg1X :: Parser Error () =
                          \u []
                              let { sat_sg1W :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sg1W;
                    } in  branch sat_sg1X sat_sg2z nt6_sg1V;
                    };
                  };
                };
              };
            };
          };
        };

sat_sg2H :: Parser Error Tm =
    \u []
        let {
          sat_sg2G :: Parser Error Tm =
              \u []
                  let {
                    sat_sg2C :: [Char] = \u [] unpackCString# "tomic expression"#; } in
                  let { sat_sg2B :: Char = CCCS C#! ['a'#]; } in
                  let { sat_sg2D :: String = CCCS :! [sat_sg2B sat_sg2C]; } in
                  let { sat_sg2E :: Expected = CCCS Msg! [sat_sg2D]; } in
                  let { sat_sg2F :: [Expected] = CCCS :! [sat_sg2E []];
                  } in  cut atomBase_reDy sat_sg2F;
        } in  >> $fMonadParser lvl' sat_sg2G;

sat_sg55 :: Pos -> Parser Error Tm =
    \r [l_sg2I]
        case l_sg2I of {
        I# ipv_sg2K ->
        let {
          sat_sg54 :: Parser Error Tm =
              \u []
                  let {
                    sat_sg3H :: Parser Error Tm =
                        \u []
                            let {
                              sat_sg3G :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sg3F :: Tm -> Parser Error Tm =
                                            \r [t_sg3x]
                                                case t_sg3x of t1_sg3y {
                                                __DEFAULT ->
                                                let {
                                                  sat_sg3E :: Parser Error Tm =
                                                      \u [] pure $fApplicativeParser t1_sg3y; } in
                                                let {
                                                  sat_sg3D :: Parser Error Tm =
                                                      \u []
                                                          let {
                                                            sat_sg3C :: Tm -> Tm =
                                                                \r [ds_sg3z]
                                                                    case ds_sg3z of dt_sg3A {
                                                                    __DEFAULT ->
                                                                    let {
                                                                      sat_sg3B :: Pos =
                                                                          CCCS I#! [ipv_sg2K];
                                                                    } in 
                                                                      Pi [sat_sg3B
                                                                          $bDontBind
                                                                          $bExpl
                                                                          t1_sg3y
                                                                          dt_sg3A];
                                                                    };
                                                          } in 
                                                            <$> $fFunctorParser sat_sg3C pi'_reDJ;
                                                } in  branch arrow_reDr sat_sg3D sat_sg3E;
                                                }; } in
                                      let {
                                        sat_sg3w :: Parser Error Tm =
                                            \u [] <* $fApplicativeParser tm'_reDQ parR'_reDq;
                                      } in  >>= $fMonadParser sat_sg3w sat_sg3F; } in
                            let {
                              sat_sg3v :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sg3u :: Parser Error Tm =
                                            \u []
                                                let {
                                                  sat_sg3t :: () -> Span -> Parser Error Tm =
                                                      \r [ds_sg2L x_sg2M]
                                                          case ds_sg2L of {
                                                          () ->
                                                          case x_sg2M of x1_sg2O {
                                                          Span _ _ ->
                                                          let {
                                                            sat_sg3s :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sg3r :: Parser Error Tm =
                                                                          \u []
                                                                              let {
                                                                                sat_sg3q
                                                                                  :: Spans
                                                                                     -> Parser
                                                                                          Error Tm =
                                                                                    \r [xs_sg2T]
                                                                                        case
                                                                                            xs_sg2T
                                                                                        of
                                                                                        xs1_sg2U
                                                                                        {
                                                                                        __DEFAULT ->
                                                                                        let {
                                                                                          sat_sg3p
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 Tm =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sg3o
                                                                                                      :: Tm
                                                                                                         -> Parser
                                                                                                              Error
                                                                                                              Tm =
                                                                                                        \r [a_sg2W]
                                                                                                            case
                                                                                                                a_sg2W
                                                                                                            of
                                                                                                            a1_sg2X
                                                                                                            {
                                                                                                            __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sg3n
                                                                                                                :: Parser
                                                                                                                     Error
                                                                                                                     Tm =
                                                                                                                  \u []
                                                                                                                      let {
                                                                                                                        sat_sg3m
                                                                                                                          :: Tm
                                                                                                                             -> Parser
                                                                                                                                  Error
                                                                                                                                  Tm =
                                                                                                                            \r [b_sg2Z]
                                                                                                                                case
                                                                                                                                    b_sg2Z
                                                                                                                                of
                                                                                                                                b1_sg30
                                                                                                                                {
                                                                                                                                __DEFAULT ->
                                                                                                                                let {
                                                                                                                                  Rec {
                                                                                                                                  go_sg31
                                                                                                                                    :: Spans
                                                                                                                                       -> Tm =
                                                                                                                                      \r [ds2_sg32]
                                                                                                                                          case
                                                                                                                                              ds2_sg32
                                                                                                                                          of
                                                                                                                                          { SNil ->
                                                                                                                                                b1_sg30;
                                                                                                                                            SCons x2_sg34
                                                                                                                                                  xs2_sg35 ->
                                                                                                                                                let {
                                                                                                                                                  sat_sg3f
                                                                                                                                                    :: Tm =
                                                                                                                                                      \u []
                                                                                                                                                          go_sg31
                                                                                                                                                              xs2_sg35; } in
                                                                                                                                                let {
                                                                                                                                                  sat_sg3e
                                                                                                                                                    :: Tm
                                                                                                                                                       -> Tm =
                                                                                                                                                      \r [eta_sg36]
                                                                                                                                                          case
                                                                                                                                                              x2_sg34
                                                                                                                                                          of
                                                                                                                                                          wild1_sg37
                                                                                                                                                          {
                                                                                                                                                          Span dt_sg38
                                                                                                                                                               _ ->
                                                                                                                                                          case
                                                                                                                                                              $bBind
                                                                                                                                                                  wild1_sg37
                                                                                                                                                          of
                                                                                                                                                          dt2_sg3a
                                                                                                                                                          {
                                                                                                                                                          Bind# _ ->
                                                                                                                                                          case
                                                                                                                                                              eta_sg36
                                                                                                                                                          of
                                                                                                                                                          dt3_sg3c
                                                                                                                                                          {
                                                                                                                                                          __DEFAULT ->
                                                                                                                                                          let {
                                                                                                                                                            sat_sg3d
                                                                                                                                                              :: Pos =
                                                                                                                                                                CCCS I#! [dt_sg38];
                                                                                                                                                          } in 
                                                                                                                                                            Pi [sat_sg3d
                                                                                                                                                                dt2_sg3a
                                                                                                                                                                $bExpl
                                                                                                                                                                a1_sg2X
                                                                                                                                                                dt3_sg3c];
                                                                                                                                                          };
                                                                                                                                                          };
                                                                                                                                                          };
                                                                                                                                                } in 
                                                                                                                                                  $!  sat_sg3e
                                                                                                                                                      sat_sg3f;
                                                                                                                                          };
                                                                                                                                  end Rec }
                                                                                                                                } in 
                                                                                                                                  case
                                                                                                                                      go_sg31
                                                                                                                                          xs1_sg2U
                                                                                                                                  of
                                                                                                                                  res_sg3g
                                                                                                                                  {
                                                                                                                                  __DEFAULT ->
                                                                                                                                  let {
                                                                                                                                    sat_sg3l
                                                                                                                                      :: Tm =
                                                                                                                                        \u []
                                                                                                                                            case
                                                                                                                                                $bBind
                                                                                                                                                    x1_sg2O
                                                                                                                                            of
                                                                                                                                            dt_sg3i
                                                                                                                                            {
                                                                                                                                            Bind# _ ->
                                                                                                                                            let {
                                                                                                                                              sat_sg3k
                                                                                                                                                :: Pos =
                                                                                                                                                  CCCS I#! [ipv_sg2K];
                                                                                                                                            } in 
                                                                                                                                              Pi [sat_sg3k
                                                                                                                                                  dt_sg3i
                                                                                                                                                  $bExpl
                                                                                                                                                  a1_sg2X
                                                                                                                                                  res_sg3g];
                                                                                                                                            }; } in
                                                                                                                                  let {
                                                                                                                                    sat_sg3h
                                                                                                                                      :: Tm
                                                                                                                                         -> Parser
                                                                                                                                              Error
                                                                                                                                              Tm =
                                                                                                                                        \u []
                                                                                                                                            pure
                                                                                                                                                $fApplicativeParser;
                                                                                                                                  } in 
                                                                                                                                    $!  sat_sg3h
                                                                                                                                        sat_sg3l;
                                                                                                                                  };
                                                                                                                                };
                                                                                                                      } in 
                                                                                                                        >>= $fMonadParser
                                                                                                                            pi'_reDJ
                                                                                                                            sat_sg3m; } in
                                                                                                            let {
                                                                                                              sat_sg2Y
                                                                                                                :: Parser
                                                                                                                     Error
                                                                                                                     () =
                                                                                                                  \u []
                                                                                                                      optional_
                                                                                                                          arrow_reDr;
                                                                                                            } in 
                                                                                                              >>  $fMonadParser
                                                                                                                  sat_sg2Y
                                                                                                                  sat_sg3n;
                                                                                                            }; } in
                                                                                                  let {
                                                                                                    sat_sg2V
                                                                                                      :: Parser
                                                                                                           Error
                                                                                                           Tm =
                                                                                                        \u []
                                                                                                            <*  $fApplicativeParser
                                                                                                                tm'_reDQ
                                                                                                                parR'_reDq;
                                                                                                  } in 
                                                                                                    >>= $fMonadParser
                                                                                                        sat_sg2V
                                                                                                        sat_sg3o;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              colon_reDh
                                                                                              sat_sg3p;
                                                                                        };
                                                                              } in 
                                                                                >>= $fMonadParser
                                                                                    manyIdents_reDH
                                                                                    sat_sg3q;
                                                                    } in 
                                                                      >>  $fMonadParser
                                                                          ws
                                                                          sat_sg3r; } in
                                                          let {
                                                            sat_sg2S :: Parser Error () =
                                                                \u []
                                                                    let {
                                                                      sat_sg2R :: Parser Error () =
                                                                          \u []
                                                                              isKeyword_reDs
                                                                                  x1_sg2O;
                                                                    } in  fails sat_sg2R;
                                                          } in  >> $fMonadParser sat_sg2S sat_sg3s;
                                                          };
                                                          };
                                                } in  spanned scanIdent_reDt sat_sg3t;
                                      } in  >> $fMonadParser lvl sat_sg3u;
                            } in  <|> sat_sg3v sat_sg3G;
                  } in 
                    case >> $fMonadParser ws sat_sg3H of nt1_sg3I {
                    __DEFAULT ->
                    let {
                      sat_sg4C :: Parser Error Tm =
                          \u []
                              let {
                                sat_sg4B :: Parser Error Tm =
                                    \u []
                                        let {
                                          sat_sg4A :: () -> Span -> Parser Error Tm =
                                              \r [ds_sg3J x_sg3K]
                                                  case ds_sg3J of {
                                                  () ->
                                                  case x_sg3K of x1_sg3M {
                                                  Span _ _ ->
                                                  let {
                                                    sat_sg4z :: Parser Error Tm =
                                                        \u []
                                                            let {
                                                              sat_sg4y :: Parser Error Tm =
                                                                  \u []
                                                                      let {
                                                                        sat_sg4x
                                                                          :: Spans
                                                                             -> Parser Error Tm =
                                                                            \r [xs_sg3R]
                                                                                case
                                                                                    xs_sg3R
                                                                                of
                                                                                xs1_sg3S
                                                                                {
                                                                                __DEFAULT ->
                                                                                let {
                                                                                  sat_sg4w
                                                                                    :: Pos
                                                                                       -> Parser
                                                                                            Error
                                                                                            Tm =
                                                                                      \r [holepos_sg3T]
                                                                                          case
                                                                                              holepos_sg3T
                                                                                          of
                                                                                          {
                                                                                          I# ipv3_sg3V ->
                                                                                          let {
                                                                                            sat_sg4v
                                                                                              :: Tm
                                                                                                 -> Parser
                                                                                                      Error
                                                                                                      Tm =
                                                                                                \r [a_sg42]
                                                                                                    case
                                                                                                        a_sg42
                                                                                                    of
                                                                                                    a1_sg43
                                                                                                    {
                                                                                                    __DEFAULT ->
                                                                                                    let {
                                                                                                      sat_sg4u
                                                                                                        :: Parser
                                                                                                             Error
                                                                                                             Tm =
                                                                                                          \u []
                                                                                                              let {
                                                                                                                sat_sg4t
                                                                                                                  :: Parser
                                                                                                                       Error
                                                                                                                       Tm =
                                                                                                                    \u []
                                                                                                                        let {
                                                                                                                          sat_sg4s
                                                                                                                            :: Tm
                                                                                                                               -> Parser
                                                                                                                                    Error
                                                                                                                                    Tm =
                                                                                                                              \r [b_sg45]
                                                                                                                                  case
                                                                                                                                      b_sg45
                                                                                                                                  of
                                                                                                                                  b1_sg46
                                                                                                                                  {
                                                                                                                                  __DEFAULT ->
                                                                                                                                  let {
                                                                                                                                    Rec {
                                                                                                                                    go_sg47
                                                                                                                                      :: Spans
                                                                                                                                         -> Tm =
                                                                                                                                        \r [ds2_sg48]
                                                                                                                                            case
                                                                                                                                                ds2_sg48
                                                                                                                                            of
                                                                                                                                            { SNil ->
                                                                                                                                                  b1_sg46;
                                                                                                                                              SCons x2_sg4a
                                                                                                                                                    xs2_sg4b ->
                                                                                                                                                  let {
                                                                                                                                                    sat_sg4l
                                                                                                                                                      :: Tm =
                                                                                                                                                        \u []
                                                                                                                                                            go_sg47
                                                                                                                                                                xs2_sg4b; } in
                                                                                                                                                  let {
                                                                                                                                                    sat_sg4k
                                                                                                                                                      :: Tm
                                                                                                                                                         -> Tm =
                                                                                                                                                        \r [eta_sg4c]
                                                                                                                                                            case
                                                                                                                                                                x2_sg4a
                                                                                                                                                            of
                                                                                                                                                            wild1_sg4d
                                                                                                                                                            {
                                                                                                                                                            Span dt_sg4e
                                                                                                                                                                 _ ->
                                                                                                                                                            case
                                                                                                                                                                $bBind
                                                                                                                                                                    wild1_sg4d
                                                                                                                                                            of
                                                                                                                                                            dt2_sg4g
                                                                                                                                                            {
                                                                                                                                                            Bind# _ ->
                                                                                                                                                            case
                                                                                                                                                                eta_sg4c
                                                                                                                                                            of
                                                                                                                                                            dt3_sg4i
                                                                                                                                                            {
                                                                                                                                                            __DEFAULT ->
                                                                                                                                                            let {
                                                                                                                                                              sat_sg4j
                                                                                                                                                                :: Pos =
                                                                                                                                                                  CCCS I#! [dt_sg4e];
                                                                                                                                                            } in 
                                                                                                                                                              Pi [sat_sg4j
                                                                                                                                                                  dt2_sg4g
                                                                                                                                                                  $bImpl
                                                                                                                                                                  a1_sg43
                                                                                                                                                                  dt3_sg4i];
                                                                                                                                                            };
                                                                                                                                                            };
                                                                                                                                                            };
                                                                                                                                                  } in 
                                                                                                                                                    $!  sat_sg4k
                                                                                                                                                        sat_sg4l;
                                                                                                                                            };
                                                                                                                                    end Rec }
                                                                                                                                  } in 
                                                                                                                                    case
                                                                                                                                        go_sg47
                                                                                                                                            xs1_sg3S
                                                                                                                                    of
                                                                                                                                    res_sg4m
                                                                                                                                    {
                                                                                                                                    __DEFAULT ->
                                                                                                                                    let {
                                                                                                                                      sat_sg4r
                                                                                                                                        :: Tm =
                                                                                                                                          \u []
                                                                                                                                              case
                                                                                                                                                  $bBind
                                                                                                                                                      x1_sg3M
                                                                                                                                              of
                                                                                                                                              dt_sg4o
                                                                                                                                              {
                                                                                                                                              Bind# _ ->
                                                                                                                                              let {
                                                                                                                                                sat_sg4q
                                                                                                                                                  :: Pos =
                                                                                                                                                    CCCS I#! [ipv_sg2K];
                                                                                                                                              } in 
                                                                                                                                                Pi [sat_sg4q
                                                                                                                                                    dt_sg4o
                                                                                                                                                    $bImpl
                                                                                                                                                    a1_sg43
                                                                                                                                                    res_sg4m];
                                                                                                                                              }; } in
                                                                                                                                    let {
                                                                                                                                      sat_sg4n
                                                                                                                                        :: Tm
                                                                                                                                           -> Parser
                                                                                                                                                Error
                                                                                                                                                Tm =
                                                                                                                                          \u []
                                                                                                                                              pure
                                                                                                                                                  $fApplicativeParser;
                                                                                                                                    } in 
                                                                                                                                      $!  sat_sg4n
                                                                                                                                          sat_sg4r;
                                                                                                                                    };
                                                                                                                                  };
                                                                                                                        } in 
                                                                                                                          >>= $fMonadParser
                                                                                                                              pi'_reDJ
                                                                                                                              sat_sg4s; } in
                                                                                                              let {
                                                                                                                sat_sg44
                                                                                                                  :: Parser
                                                                                                                       Error
                                                                                                                       () =
                                                                                                                    \u []
                                                                                                                        optional_
                                                                                                                            arrow_reDr;
                                                                                                              } in 
                                                                                                                >>  $fMonadParser
                                                                                                                    sat_sg44
                                                                                                                    sat_sg4t;
                                                                                                    } in 
                                                                                                      >>  $fMonadParser
                                                                                                          braceR'_reDm
                                                                                                          sat_sg4u;
                                                                                                    }; } in
                                                                                          let {
                                                                                            sat_sg41
                                                                                              :: Parser
                                                                                                   Error
                                                                                                   Tm =
                                                                                                \u []
                                                                                                    let {
                                                                                                      sat_sg40
                                                                                                        :: Parser
                                                                                                             Error
                                                                                                             Tm =
                                                                                                          \u []
                                                                                                              let {
                                                                                                                sat_sg3Y
                                                                                                                  :: Pos =
                                                                                                                    CCCS I#! [ipv3_sg3V]; } in
                                                                                                              let {
                                                                                                                sat_sg3Z
                                                                                                                  :: Tm =
                                                                                                                    CCCS Hole! [sat_sg3Y];
                                                                                                              } in 
                                                                                                                pure
                                                                                                                    $fApplicativeParser
                                                                                                                    sat_sg3Z; } in
                                                                                                    let {
                                                                                                      sat_sg3X
                                                                                                        :: Tm
                                                                                                           -> Parser
                                                                                                                Error
                                                                                                                Tm =
                                                                                                          \u []
                                                                                                              pure
                                                                                                                  $fApplicativeParser; } in
                                                                                                    let {
                                                                                                      sat_sg3W
                                                                                                        :: Parser
                                                                                                             Error
                                                                                                             Tm =
                                                                                                          \u []
                                                                                                              *>  $fApplicativeParser
                                                                                                                  colon_reDh
                                                                                                                  tm'_reDQ;
                                                                                                    } in 
                                                                                                      optioned
                                                                                                          sat_sg3W
                                                                                                          sat_sg3X
                                                                                                          sat_sg40;
                                                                                          } in 
                                                                                            >>= $fMonadParser
                                                                                                sat_sg41
                                                                                                sat_sg4v;
                                                                                          };
                                                                                } in 
                                                                                  >>= $fMonadParser
                                                                                      getPos
                                                                                      sat_sg4w;
                                                                                };
                                                                      } in 
                                                                        >>= $fMonadParser
                                                                            manyIdents_reDH
                                                                            sat_sg4x;
                                                            } in  >> $fMonadParser ws sat_sg4y; } in
                                                  let {
                                                    sat_sg3Q :: Parser Error () =
                                                        \u []
                                                            let {
                                                              sat_sg3P :: Parser Error () =
                                                                  \u [] isKeyword_reDs x1_sg3M;
                                                            } in  fails sat_sg3P;
                                                  } in  >> $fMonadParser sat_sg3Q sat_sg4z;
                                                  };
                                                  };
                                        } in  spanned scanIdent_reDt sat_sg4A;
                              } in  >> $fMonadParser lvl sat_sg4B;
                    } in 
                      case >> $fMonadParser ws sat_sg4C of nt2_sg4D {
                      __DEFAULT ->
                      let {
                        sat_sg4N :: Parser Error Tm =
                            \u []
                                let {
                                  sat_sg4M :: Tm -> Parser Error Tm =
                                      \r [t_sg4E]
                                          case t_sg4E of t1_sg4F {
                                          __DEFAULT ->
                                          let {
                                            sat_sg4L :: Parser Error Tm =
                                                \u [] pure $fApplicativeParser t1_sg4F; } in
                                          let {
                                            sat_sg4K :: Parser Error Tm =
                                                \u []
                                                    let {
                                                      sat_sg4J :: Tm -> Tm =
                                                          \r [ds_sg4G]
                                                              case ds_sg4G of dt_sg4H {
                                                              __DEFAULT ->
                                                              let {
                                                                sat_sg4I :: Pos =
                                                                    CCCS I#! [ipv_sg2K];
                                                              } in 
                                                                Pi [sat_sg4I
                                                                    $bDontBind
                                                                    $bExpl
                                                                    t1_sg4F
                                                                    dt_sg4H];
                                                              };
                                                    } in  <$> $fFunctorParser sat_sg4J pi'_reDJ;
                                          } in  branch arrow_reDr sat_sg4K sat_sg4L;
                                          };
                                } in  >>= $fMonadParser app'_reDD sat_sg4M;
                      } in 
                        case >> $fMonadParser ws sat_sg4N of nt3_sg4O {
                        __DEFAULT ->
                        let {
                          sat_sg53 :: Parser Error Tm =
                              \u []
                                  let {
                                    sat_sg52 :: Word8 -> Parser Error Tm =
                                        \r [c_sg4R]
                                            case c_sg4R of c1_sg4S {
                                            W8# _ ->
                                            let {
                                              sat_sg4V :: Word8 =
                                                  \u []
                                                      let { sat_sg4U :: Integer = CCCS IS! [40#];
                                                      } in  fromInteger $fNumWord8 sat_sg4U;
                                            } in 
                                              case == $fEqWord8 c1_sg4S sat_sg4V of {
                                                False ->
                                                    let {
                                                      sat_sg4Y :: Word8 =
                                                          \u []
                                                              let {
                                                                sat_sg4X :: Integer =
                                                                    CCCS IS! [123#];
                                                              } in  fromInteger $fNumWord8 sat_sg4X;
                                                    } in 
                                                      case == $fEqWord8 c1_sg4S sat_sg4Y of {
                                                        False ->
                                                            let {
                                                              sat_sg51 :: Parser Error () =
                                                                  \u []
                                                                      let {
                                                                        sat_sg50 :: Int =
                                                                            CCCS I#! [1#];
                                                                      } in  setBack# sat_sg50;
                                                            } in 
                                                              >> $fMonadParser sat_sg51 nt3_sg4O;
                                                        True -> nt2_sg4D;
                                                      };
                                                True -> nt1_sg3I;
                                              };
                                            };
                                  } in  >>= $fMonadParser scanAny8# sat_sg52; } in
                        let {
                          sat_sg4Q :: Parser Error () =
                              \u []
                                  let { sat_sg4P :: Int = CCCS I#! [1#];
                                  } in  ensureBytes# sat_sg4P;
                        } in  branch sat_sg4Q sat_sg53 nt3_sg4O;
                        };
                      };
                    };
        } in  >> $fMonadParser lvl' sat_sg54;
        };

atom_reDz :: Parser Tm = \u [] >> $fMonadParser lvl atomBase_reDy;

goLamParL_reDL :: Pos -> Parser Tm =
    \r [pos_sfTW]
        case pos_sfTW of {
        I# ipv_sfTY ->
        let {
          sat_sfUv :: Parser Error Tm =
              \u []
                  let {
                    sat_sfUu :: Parser Error Tm =
                        \u []
                            let { sat_sfUr :: [Char] = \u [] unpackCString# "dentifier"#; } in
                            let { sat_sfUq :: Char = CCCS C#! ['i'#]; } in
                            let { sat_sfUs :: String = CCCS :! [sat_sfUq sat_sfUr]; } in
                            let { sat_sfUt :: Expected = CCCS Msg! [sat_sfUs]; } in
                            let {
                              sat_sfUp :: Parser Tm =
                                  \u []
                                      let {
                                        sat_sfUo :: () -> Span -> Parser Error Tm =
                                            \r [ds_sfTZ x_sfU0]
                                                case ds_sfTZ of {
                                                () ->
                                                case x_sfU0 of x1_sfU2 {
                                                Span _ _ ->
                                                let {
                                                  sat_sfUn :: Parser Error Tm =
                                                      \u []
                                                          let {
                                                            sat_sfUm :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sfUl
                                                                        :: Tm -> Parser Error Tm =
                                                                          \r [a_sfU9]
                                                                              case
                                                                                  a_sfU9
                                                                              of
                                                                              a1_sfUa
                                                                              {
                                                                              __DEFAULT ->
                                                                              let {
                                                                                sat_sfUk
                                                                                  :: Tm -> Tm =
                                                                                    \r [ds2_sfUb]
                                                                                        case
                                                                                            $bBind
                                                                                                x1_sfU2
                                                                                        of
                                                                                        dt_sfUc
                                                                                        {
                                                                                        Bind# _ ->
                                                                                        case
                                                                                            $bNoName
                                                                                                $bExpl
                                                                                        of
                                                                                        dt1_sfUe
                                                                                        {
                                                                                        ArgInfo# _ ->
                                                                                        case
                                                                                            $bUJust
                                                                                                a1_sfUa
                                                                                        of
                                                                                        dt2_sfUg
                                                                                        {
                                                                                        UMaybe# _ ->
                                                                                        case
                                                                                            ds2_sfUb
                                                                                        of
                                                                                        dt3_sfUi
                                                                                        {
                                                                                        __DEFAULT ->
                                                                                        let {
                                                                                          sat_sfUj
                                                                                            :: Pos =
                                                                                              CCCS I#! [ipv_sfTY];
                                                                                        } in 
                                                                                          Lam [sat_sfUj
                                                                                               dt_sfUc
                                                                                               dt1_sfUe
                                                                                               dt2_sfUg
                                                                                               dt3_sfUi];
                                                                                        };
                                                                                        };
                                                                                        };
                                                                                        };
                                                                              } in 
                                                                                <$> $fFunctorParser
                                                                                    sat_sfUk
                                                                                    goLam_reDM;
                                                                              }; } in
                                                                    let {
                                                                      sat_sfU8 :: Parser Error Tm =
                                                                          \u []
                                                                              let {
                                                                                sat_sfU7
                                                                                  :: Parser
                                                                                       Error Tm =
                                                                                    \u []
                                                                                        *>  $fApplicativeParser
                                                                                            colon'_reDi
                                                                                            tm'_reDQ;
                                                                              } in 
                                                                                <*  $fApplicativeParser
                                                                                    sat_sfU7
                                                                                    parR'_reDq;
                                                                    } in 
                                                                      >>= $fMonadParser
                                                                          sat_sfU8
                                                                          sat_sfUl;
                                                          } in  >> $fMonadParser ws sat_sfUm; } in
                                                let {
                                                  sat_sfU6 :: Parser Error () =
                                                      \u []
                                                          let {
                                                            sat_sfU5 :: Parser Error () =
                                                                \u [] isKeyword_reDs x1_sfU2;
                                                          } in  fails sat_sfU5;
                                                } in  >> $fMonadParser sat_sfU6 sat_sfUn;
                                                };
                                                };
                                      } in  spanned scanIdent_reDt sat_sfUo;
                            } in  cut' sat_sfUp sat_sfUt;
                  } in  >> $fMonadParser lvl' sat_sfUu;
        } in  >> $fMonadParser ws sat_sfUv;
        };

goApp_reDC :: Tm -> Parser Tm =
    \r [t_sfUw]
        case t_sfUw of t1_sfUx {
        __DEFAULT ->
        let {
          sat_sfV9 :: Parser Error Tm =
              \u []
                  let {
                    sat_sfV8 :: Parser Error Tm =
                        \u [] pure $fApplicativeParser t1_sfUx; } in
                  let {
                    sat_sfV7 :: Tm -> Parser Error Tm =
                        \r [u_sfV2]
                            case u_sfV2 of u1_sfV3 {
                            __DEFAULT ->
                            let {
                              sat_sfV6 :: Tm =
                                  \u []
                                      case $bNoName $bExpl of dt_sfV4 {
                                      ArgInfo# _ -> App [t1_sfUx u1_sfV3 dt_sfV4];
                                      };
                            } in  goApp_reDC sat_sfV6;
                            };
                  } in  optioned atom_reDz sat_sfV7 sat_sfV8; } in
        let {
          sat_sfV1 :: Parser Error Tm =
              \u []
                  let {
                    sat_sfV0 :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfUZ :: Tm -> Parser Error Tm =
                                  \r [u_sfUT]
                                      case u_sfUT of u1_sfUU {
                                      __DEFAULT ->
                                      let {
                                        sat_sfUY :: Parser Error Tm =
                                            \u []
                                                let {
                                                  sat_sfUX :: Tm =
                                                      \u []
                                                          case $bNoName $bImpl of dt_sfUV {
                                                          ArgInfo# _ ->
                                                          App [t1_sfUx u1_sfUU dt_sfUV];
                                                          };
                                                } in  goApp_reDC sat_sfUX;
                                      } in  >> $fMonadParser braceR'_reDm sat_sfUY;
                                      };
                            } in  >>= $fMonadParser tm'_reDQ sat_sfUZ; } in
                  let {
                    sat_sfUS :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfUR :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sfUQ :: () -> Span -> Parser Error Tm =
                                            \r [ds_sfUy x_sfUz]
                                                case ds_sfUy of {
                                                () ->
                                                case x_sfUz of x1_sfUB {
                                                Span _ _ ->
                                                let {
                                                  sat_sfUP :: Parser Error Tm =
                                                      \u []
                                                          let {
                                                            sat_sfUO :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sfUN :: Parser Error Tm =
                                                                          \u []
                                                                              let {
                                                                                sat_sfUM
                                                                                  :: Tm
                                                                                     -> Parser
                                                                                          Error Tm =
                                                                                    \r [u_sfUG]
                                                                                        case
                                                                                            u_sfUG
                                                                                        of
                                                                                        u1_sfUH
                                                                                        {
                                                                                        __DEFAULT ->
                                                                                        let {
                                                                                          sat_sfUL
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 Tm =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfUK
                                                                                                      :: Tm =
                                                                                                        \u []
                                                                                                            case
                                                                                                                $bNamed
                                                                                                                    x1_sfUB
                                                                                                            of
                                                                                                            dt_sfUI
                                                                                                            {
                                                                                                            ArgInfo# _ ->
                                                                                                            App [t1_sfUx
                                                                                                                 u1_sfUH
                                                                                                                 dt_sfUI];
                                                                                                            };
                                                                                                  } in 
                                                                                                    goApp_reDC
                                                                                                        sat_sfUK;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              braceR'_reDm
                                                                                              sat_sfUL;
                                                                                        };
                                                                              } in 
                                                                                >>= $fMonadParser
                                                                                    tm'_reDQ
                                                                                    sat_sfUM;
                                                                    } in 
                                                                      >>  $fMonadParser
                                                                          eq_reDo
                                                                          sat_sfUN;
                                                          } in  >> $fMonadParser ws sat_sfUO; } in
                                                let {
                                                  sat_sfUF :: Parser Error () =
                                                      \u []
                                                          let {
                                                            sat_sfUE :: Parser Error () =
                                                                \u [] isKeyword_reDs x1_sfUB;
                                                          } in  fails sat_sfUE;
                                                } in  >> $fMonadParser sat_sfUF sat_sfUP;
                                                };
                                                };
                                      } in  spanned scanIdent_reDt sat_sfUQ;
                            } in  >> $fMonadParser lvl sat_sfUR;
                  } in  <|> sat_sfUS sat_sfV0;
        } in  branch braceL_reDl sat_sfV1 sat_sfV9;
        };

goLamBraceL_reDK :: Pos -> Parser Tm =
    \r [pos_sfVa]
        case pos_sfVa of {
        I# ipv_sfVc ->
        let {
          sat_sfWu :: Parser Error Tm =
              \u []
                  let {
                    sat_sfWt :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfWs :: Parser Error Tm =
                                  \u []
                                      let {
                                        sat_sfWp :: [Char] = \u [] unpackCString# "dentifier"#; } in
                                      let { sat_sfWo :: Char = CCCS C#! ['i'#]; } in
                                      let { sat_sfWq :: String = CCCS :! [sat_sfWo sat_sfWp]; } in
                                      let { sat_sfWr :: Expected = CCCS Msg! [sat_sfWq]; } in
                                      let {
                                        sat_sfWn :: Parser Tm =
                                            \u []
                                                let {
                                                  sat_sfWm :: () -> Span -> Parser Error Tm =
                                                      \r [ds_sfVw x_sfVx]
                                                          case ds_sfVw of {
                                                          () ->
                                                          case x_sfVx of x1_sfVz {
                                                          Span _ _ ->
                                                          let {
                                                            sat_sfWl :: Parser Error Tm =
                                                                \u []
                                                                    let {
                                                                      sat_sfWk :: Parser Error Tm =
                                                                          \u []
                                                                              let {
                                                                                sat_sfWj
                                                                                  :: Parser
                                                                                       Error Tm =
                                                                                    \u []
                                                                                        let {
                                                                                          sat_sfWi
                                                                                            :: UMaybe
                                                                                                 Tm
                                                                                               -> Parser
                                                                                                    Error
                                                                                                    Tm =
                                                                                              \r [a_sfW6]
                                                                                                  case
                                                                                                      a_sfW6
                                                                                                  of
                                                                                                  a1_sfW7
                                                                                                  {
                                                                                                  UMaybe# _ ->
                                                                                                  let {
                                                                                                    sat_sfWh
                                                                                                      :: Parser
                                                                                                           Error
                                                                                                           Tm =
                                                                                                        \u []
                                                                                                            *>  $fApplicativeParser
                                                                                                                braceR'_reDm
                                                                                                                goLam_reDM; } in
                                                                                                  let {
                                                                                                    sat_sfWg
                                                                                                      :: Tm
                                                                                                         -> Tm =
                                                                                                        \r [ds2_sfW9]
                                                                                                            case
                                                                                                                $bBind
                                                                                                                    x1_sfVz
                                                                                                            of
                                                                                                            dt_sfWa
                                                                                                            {
                                                                                                            Bind# _ ->
                                                                                                            case
                                                                                                                $bNoName
                                                                                                                    $bImpl
                                                                                                            of
                                                                                                            dt1_sfWc
                                                                                                            {
                                                                                                            ArgInfo# _ ->
                                                                                                            case
                                                                                                                ds2_sfW9
                                                                                                            of
                                                                                                            dt2_sfWe
                                                                                                            {
                                                                                                            __DEFAULT ->
                                                                                                            let {
                                                                                                              sat_sfWf
                                                                                                                :: Pos =
                                                                                                                  CCCS I#! [ipv_sfVc];
                                                                                                            } in 
                                                                                                              Lam [sat_sfWf
                                                                                                                   dt_sfWa
                                                                                                                   dt1_sfWc
                                                                                                                   a1_sfW7
                                                                                                                   dt2_sfWe];
                                                                                                            };
                                                                                                            };
                                                                                                            };
                                                                                                  } in 
                                                                                                    <$> $fFunctorParser
                                                                                                        sat_sfWg
                                                                                                        sat_sfWh;
                                                                                                  }; } in
                                                                                        let {
                                                                                          sat_sfW5
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 Tm =
                                                                                              \u []
                                                                                                  *>  $fApplicativeParser
                                                                                                      colon_reDh
                                                                                                      tm'_reDQ;
                                                                                        } in 
                                                                                          uoptioned
                                                                                              sat_sfW5
                                                                                              sat_sfWi; } in
                                                                              let {
                                                                                sat_sfW4
                                                                                  :: Parser
                                                                                       Error Tm =
                                                                                    \u []
                                                                                        let {
                                                                                          sat_sfW3
                                                                                            :: Parser
                                                                                                 Error
                                                                                                 Tm =
                                                                                              \u []
                                                                                                  let {
                                                                                                    sat_sfW0
                                                                                                      :: [Char] =
                                                                                                        \u []
                                                                                                            unpackCString#
                                                                                                                "dentifier"#; } in
                                                                                                  let {
                                                                                                    sat_sfVZ
                                                                                                      :: Char =
                                                                                                        CCCS C#! ['i'#]; } in
                                                                                                  let {
                                                                                                    sat_sfW1
                                                                                                      :: String =
                                                                                                        CCCS :! [sat_sfVZ
                                                                                                                 sat_sfW0]; } in
                                                                                                  let {
                                                                                                    sat_sfW2
                                                                                                      :: Expected =
                                                                                                        CCCS Msg! [sat_sfW1]; } in
                                                                                                  let {
                                                                                                    sat_sfVY
                                                                                                      :: Parser
                                                                                                           Tm =
                                                                                                        \u []
                                                                                                            let {
                                                                                                              sat_sfVX
                                                                                                                :: ()
                                                                                                                   -> Span
                                                                                                                   -> Parser
                                                                                                                        Error
                                                                                                                        Tm =
                                                                                                                  \r [ds2_sfVE
                                                                                                                      x2_sfVF]
                                                                                                                      case
                                                                                                                          ds2_sfVE
                                                                                                                      of
                                                                                                                      {
                                                                                                                      () ->
                                                                                                                      case
                                                                                                                          x2_sfVF
                                                                                                                      of
                                                                                                                      x3_sfVH
                                                                                                                      {
                                                                                                                      Span _
                                                                                                                           _ ->
                                                                                                                      let {
                                                                                                                        sat_sfVW
                                                                                                                          :: Parser
                                                                                                                               Error
                                                                                                                               Tm =
                                                                                                                            \u []
                                                                                                                                let {
                                                                                                                                  sat_sfVV
                                                                                                                                    :: Parser
                                                                                                                                         Error
                                                                                                                                         Tm =
                                                                                                                                      \u []
                                                                                                                                          let {
                                                                                                                                            sat_sfVU
                                                                                                                                              :: Parser
                                                                                                                                                   Error
                                                                                                                                                   Tm =
                                                                                                                                                \u []
                                                                                                                                                    *>  $fApplicativeParser
                                                                                                                                                        braceR'_reDm
                                                                                                                                                        goLam_reDM; } in
                                                                                                                                          let {
                                                                                                                                            sat_sfVT
                                                                                                                                              :: Tm
                                                                                                                                                 -> Tm =
                                                                                                                                                \r [ds4_sfVM]
                                                                                                                                                    case
                                                                                                                                                        $bBind
                                                                                                                                                            x3_sfVH
                                                                                                                                                    of
                                                                                                                                                    dt_sfVN
                                                                                                                                                    {
                                                                                                                                                    Bind# _ ->
                                                                                                                                                    case
                                                                                                                                                        $bNamed
                                                                                                                                                            x1_sfVz
                                                                                                                                                    of
                                                                                                                                                    dt1_sfVP
                                                                                                                                                    {
                                                                                                                                                    ArgInfo# _ ->
                                                                                                                                                    case
                                                                                                                                                        ds4_sfVM
                                                                                                                                                    of
                                                                                                                                                    dt2_sfVR
                                                                                                                                                    {
                                                                                                                                                    __DEFAULT ->
                                                                                                                                                    let {
                                                                                                                                                      sat_sfVS
                                                                                                                                                        :: Pos =
                                                                                                                                                          CCCS I#! [ipv_sfVc];
                                                                                                                                                    } in 
                                                                                                                                                      Lam [sat_sfVS
                                                                                                                                                           dt_sfVN
                                                                                                                                                           dt1_sfVP
                                                                                                                                                           $bUNothing
                                                                                                                                                           dt2_sfVR];
                                                                                                                                                    };
                                                                                                                                                    };
                                                                                                                                                    };
                                                                                                                                          } in 
                                                                                                                                            <$> $fFunctorParser
                                                                                                                                                sat_sfVT
                                                                                                                                                sat_sfVU;
                                                                                                                                } in 
                                                                                                                                  >>  $fMonadParser
                                                                                                                                      ws
                                                                                                                                      sat_sfVV; } in
                                                                                                                      let {
                                                                                                                        sat_sfVL
                                                                                                                          :: Parser
                                                                                                                               Error
                                                                                                                               () =
                                                                                                                            \u []
                                                                                                                                let {
                                                                                                                                  sat_sfVK
                                                                                                                                    :: Parser
                                                                                                                                         Error
                                                                                                                                         () =
                                                                                                                                      \u []
                                                                                                                                          isKeyword_reDs
                                                                                                                                              x3_sfVH;
                                                                                                                                } in 
                                                                                                                                  fails
                                                                                                                                      sat_sfVK;
                                                                                                                      } in 
                                                                                                                        >>  $fMonadParser
                                                                                                                            sat_sfVL
                                                                                                                            sat_sfVW;
                                                                                                                      };
                                                                                                                      };
                                                                                                            } in 
                                                                                                              spanned
                                                                                                                  scanIdent_reDt
                                                                                                                  sat_sfVX;
                                                                                                  } in 
                                                                                                    cut'
                                                                                                        sat_sfVY
                                                                                                        sat_sfW2;
                                                                                        } in 
                                                                                          >>  $fMonadParser
                                                                                              lvl'
                                                                                              sat_sfW3;
                                                                              } in 
                                                                                branch
                                                                                    eq_reDo
                                                                                    sat_sfW4
                                                                                    sat_sfWj;
                                                                    } in 
                                                                      >>  $fMonadParser
                                                                          ws
                                                                          sat_sfWk; } in
                                                          let {
                                                            sat_sfVD :: Parser Error () =
                                                                \u []
                                                                    let {
                                                                      sat_sfVC :: Parser Error () =
                                                                          \u []
                                                                              isKeyword_reDs
                                                                                  x1_sfVz;
                                                                    } in  fails sat_sfVC;
                                                          } in  >> $fMonadParser sat_sfVD sat_sfWl;
                                                          };
                                                          };
                                                } in  spanned scanIdent_reDt sat_sfWm;
                                      } in  cut' sat_sfWn sat_sfWr;
                            } in  >> $fMonadParser lvl' sat_sfWs; } in
                  let {
                    sat_sfVv :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfVu :: UMaybe Tm -> Parser Error Tm =
                                  \r [a_sfVk]
                                      case a_sfVk of a1_sfVl {
                                      UMaybe# _ ->
                                      let {
                                        sat_sfVt :: Parser Error Tm =
                                            \u []
                                                *> $fApplicativeParser braceR'_reDm goLam_reDM; } in
                                      let {
                                        sat_sfVs :: Tm -> Tm =
                                            \r [ds_sfVn]
                                                case $bNoName $bImpl of dt_sfVo {
                                                ArgInfo# _ ->
                                                case ds_sfVn of dt1_sfVq {
                                                __DEFAULT ->
                                                let { sat_sfVr :: Pos = CCCS I#! [ipv_sfVc];
                                                } in 
                                                  Lam [sat_sfVr
                                                       $bDontBind
                                                       dt_sfVo
                                                       a1_sfVl
                                                       dt1_sfVq];
                                                };
                                                };
                                      } in  <$> $fFunctorParser sat_sfVs sat_sfVt;
                                      }; } in
                            let {
                              sat_sfVj :: Parser Error Tm =
                                  \u [] *> $fApplicativeParser colon_reDh tm'_reDQ;
                            } in  uoptioned sat_sfVj sat_sfVu; } in
                  let {
                    sat_sfVi :: Parser Error () =
                        \u []
                            let {
                              sat_sfVh :: Parser () =
                                  \u []
                                      let {
                                        sat_sfVg :: Parser Error () =
                                            \u []
                                                let { sat_sfVf :: Word = CCCS W#! [95##];
                                                } in  scan8# sat_sfVf; } in
                                      let {
                                        sat_sfVe :: Parser Error () =
                                            \u []
                                                let { sat_sfVd :: Int = CCCS I#! [1#];
                                                } in  ensureBytes# sat_sfVd;
                                      } in  >> $fMonadParser sat_sfVe sat_sfVg;
                            } in  token sat_sfVh;
                  } in  branch sat_sfVi sat_sfVv sat_sfWt;
        } in  >> $fMonadParser ws sat_sfWu;
        };

lam'_reDN :: Pos -> Parser Tm =
    \r [pos_sfWv]
        case pos_sfWv of nt_sfWw {
        I# ipv_sfWx ->
        let {
          sat_sfXr :: Parser Error Tm =
              \u []
                  let {
                    sat_sfWE :: Parser Error Tm =
                        \u []
                            let {
                              sat_sfWD :: Tm -> Tm =
                                  \r [ds_sfWy]
                                      case $bNoName $bExpl of dt_sfWz {
                                      ArgInfo# _ ->
                                      case ds_sfWy of dt1_sfWB {
                                      __DEFAULT ->
                                      let { sat_sfWC :: Pos = CCCS I#! [ipv_sfWx];
                                      } in  Lam [sat_sfWC $bDontBind dt_sfWz $bUNothing dt1_sfWB];
                                      };
                                      };
                            } in  <$> $fFunctorParser sat_sfWD goLam_reDM;
                  } in 
                    case >> $fMonadParser ws sat_sfWE of nt1_sfWF {
                    __DEFAULT ->
                    case goLamParL_reDL nt_sfWw of nt2_sfWG {
                    __DEFAULT ->
                    case goLamBraceL_reDK nt_sfWw of nt3_sfWH {
                    __DEFAULT ->
                    let {
                      sat_sfX7 :: Parser Error Tm =
                          \u []
                              let {
                                sat_sfX6 :: Parser Error Tm =
                                    \u []
                                        let {
                                          sat_sfX3 :: [Char] =
                                              \u [] unpackCString# "dentifier"#; } in
                                        let { sat_sfX2 :: Char = CCCS C#! ['i'#]; } in
                                        let { sat_sfX4 :: String = CCCS :! [sat_sfX2 sat_sfX3]; } in
                                        let { sat_sfX5 :: Expected = CCCS Msg! [sat_sfX4]; } in
                                        let {
                                          sat_sfX1 :: Parser Tm =
                                              \u []
                                                  let {
                                                    sat_sfX0 :: () -> Span -> Parser Error Tm =
                                                        \r [ds_sfWI x_sfWJ]
                                                            case ds_sfWI of {
                                                            () ->
                                                            case x_sfWJ of x1_sfWL {
                                                            Span _ _ ->
                                                            let {
                                                              sat_sfWZ :: Parser Error Tm =
                                                                  \u []
                                                                      let {
                                                                        sat_sfWY
                                                                          :: Parser Error Tm =
                                                                            \u []
                                                                                let {
                                                                                  sat_sfWX
                                                                                    :: Tm -> Tm =
                                                                                      \r [ds2_sfWQ]
                                                                                          case
                                                                                              $bBind
                                                                                                  x1_sfWL
                                                                                          of
                                                                                          dt_sfWR
                                                                                          {
                                                                                          Bind# _ ->
                                                                                          case
                                                                                              $bNoName
                                                                                                  $bExpl
                                                                                          of
                                                                                          dt1_sfWT
                                                                                          {
                                                                                          ArgInfo# _ ->
                                                                                          case
                                                                                              ds2_sfWQ
                                                                                          of
                                                                                          dt2_sfWV
                                                                                          {
                                                                                          __DEFAULT ->
                                                                                          let {
                                                                                            sat_sfWW
                                                                                              :: Pos =
                                                                                                CCCS I#! [ipv_sfWx];
                                                                                          } in 
                                                                                            Lam [sat_sfWW
                                                                                                 dt_sfWR
                                                                                                 dt1_sfWT
                                                                                                 $bUNothing
                                                                                                 dt2_sfWV];
                                                                                          };
                                                                                          };
                                                                                          };
                                                                                } in 
                                                                                  <$> $fFunctorParser
                                                                                      sat_sfWX
                                                                                      goLam_reDM;
                                                                      } in 
                                                                        >>  $fMonadParser
                                                                            ws
                                                                            sat_sfWY; } in
                                                            let {
                                                              sat_sfWP :: Parser Error () =
                                                                  \u []
                                                                      let {
                                                                        sat_sfWO
                                                                          :: Parser Error () =
                                                                            \u []
                                                                                isKeyword_reDs
                                                                                    x1_sfWL;
                                                                      } in  fails sat_sfWO;
                                                            } in 
                                                              >> $fMonadParser sat_sfWP sat_sfWZ;
                                                            };
                                                            };
                                                  } in  spanned scanIdent_reDt sat_sfX0;
                                        } in  cut' sat_sfX1 sat_sfX5;
                              } in  >> $fMonadParser lvl' sat_sfX6;
                    } in 
                      case >> $fMonadParser ws sat_sfX7 of nt4_sfX8 {
                      __DEFAULT ->
                      let {
                        sat_sfXq :: Parser Error Tm =
                            \u []
                                let {
                                  sat_sfXp :: Word8 -> Parser Error Tm =
                                      \r [c_sfXb]
                                          case c_sfXb of c1_sfXc {
                                          W8# _ ->
                                          let {
                                            sat_sfXf :: Word8 =
                                                \u []
                                                    let { sat_sfXe :: Integer = CCCS IS! [40#];
                                                    } in  fromInteger $fNumWord8 sat_sfXe;
                                          } in 
                                            case == $fEqWord8 c1_sfXc sat_sfXf of {
                                              False ->
                                                  let {
                                                    sat_sfXi :: Word8 =
                                                        \u []
                                                            let {
                                                              sat_sfXh :: Integer = CCCS IS! [95#];
                                                            } in  fromInteger $fNumWord8 sat_sfXh;
                                                  } in 
                                                    case == $fEqWord8 c1_sfXc sat_sfXi of {
                                                      False ->
                                                          let {
                                                            sat_sfXl :: Word8 =
                                                                \u []
                                                                    let {
                                                                      sat_sfXk :: Integer =
                                                                          CCCS IS! [123#];
                                                                    } in 
                                                                      fromInteger
                                                                          $fNumWord8 sat_sfXk;
                                                          } in 
                                                            case == $fEqWord8 c1_sfXc sat_sfXl of {
                                                              False ->
                                                                  let {
                                                                    sat_sfXo :: Parser Error () =
                                                                        \u []
                                                                            let {
                                                                              sat_sfXn :: Int =
                                                                                  CCCS I#! [1#];
                                                                            } in  setBack# sat_sfXn;
                                                                  } in 
                                                                    >>  $fMonadParser
                                                                        sat_sfXo
                                                                        nt4_sfX8;
                                                              True -> nt3_sfWH;
                                                            };
                                                      True -> nt1_sfWF;
                                                    };
                                              True -> nt2_sfWG;
                                            };
                                          };
                                } in  >>= $fMonadParser scanAny8# sat_sfXp; } in
                      let {
                        sat_sfXa :: Parser Error () =
                            \u []
                                let { sat_sfX9 :: Int = CCCS I#! [1#]; } in  ensureBytes# sat_sfX9;
                      } in  branch sat_sfXa sat_sfXq nt4_sfX8;
                      };
                    };
                    };
                    };
        } in  >> $fMonadParser lvl' sat_sfXr;
        };

tm'_reDQ :: Parser Tm = \u [] >> $fMonadParser lvl' sat_sfZu;

goLam_reDM :: Parser Tm = \u [] >>= $fMonadParser getPos sat_sg0w;

atomBase_reDy :: Parser Tm =
    \u [] >>= $fMonadParser getPos sat_sg2A;

app'_reDD :: Parser Tm =
    \u [] =<< $fMonadParser goApp_reDC sat_sg2H;

pi'_reDJ :: Parser Tm = \u [] >>= $fMonadParser getPos sat_sg55;
end Rec }

Rec {
sat_sg5X :: Parser Error TopLevel =
    \u []
        let {
          sat_sg5W :: Parser Error () =
              \u []
                  let {
                    sat_sg5R :: [Char] =
                        \u [] unpackCString# "op-level definition at column 1"#; } in
                  let { sat_sg5Q :: Char = CCCS C#! ['t'#]; } in
                  let { sat_sg5S :: String = CCCS :! [sat_sg5Q sat_sg5R]; } in
                  let { sat_sg5T :: Expected = CCCS Msg! [sat_sg5S]; } in
                  let { sat_sg5U :: [Expected] = CCCS :! [sat_sg5T []]; } in
                  let { sat_sg5N :: [Char] = \u [] unpackCString# "nd of file"#; } in
                  let { sat_sg5M :: Char = CCCS C#! ['e'#]; } in
                  let { sat_sg5O :: String = CCCS :! [sat_sg5M sat_sg5N]; } in
                  let { sat_sg5P :: Expected = CCCS Msg! [sat_sg5O]; } in
                  let { sat_sg5V :: [Expected] = CCCS :! [sat_sg5P sat_sg5U];
                  } in  cut eof sat_sg5V;
        } in  <$ $fFunctorParser Nil sat_sg5W;

sat_sg5L :: Parser Error TopLevel =
    \u []
        let {
          sat_sg5K :: Parser Error TopLevel =
              \u []
                  let {
                    sat_sg5J :: Span -> Parser Error TopLevel =
                        \r [x_sg5m]
                            case x_sg5m of x1_sg5n {
                            Span _ _ ->
                            let {
                              sat_sg5I :: Parser Error TopLevel =
                                  \u []
                                      let {
                                        sat_sg5H :: UMaybe Tm -> Parser Error TopLevel =
                                            \r [a_sg5u]
                                                case a_sg5u of a1_sg5v {
                                                UMaybe# _ ->
                                                let {
                                                  sat_sg5G :: Parser Error TopLevel =
                                                      \u []
                                                          let {
                                                            sat_sg5F
                                                              :: Tm -> Parser Error TopLevel =
                                                                \r [rhs_sg5x]
                                                                    case rhs_sg5x of rhs1_sg5y {
                                                                    __DEFAULT ->
                                                                    let {
                                                                      sat_sg5E
                                                                        :: Parser Error TopLevel =
                                                                          \u []
                                                                              let {
                                                                                sat_sg5D
                                                                                  :: TopLevel
                                                                                     -> TopLevel =
                                                                                    \r [ds_sg5B]
                                                                                        case
                                                                                            ds_sg5B
                                                                                        of
                                                                                        dt_sg5C
                                                                                        {
                                                                                        __DEFAULT ->
                                                                                        Definition [x1_sg5n
                                                                                                    a1_sg5v
                                                                                                    rhs1_sg5y
                                                                                                    dt_sg5C];
                                                                                        };
                                                                              } in 
                                                                                <$> $fFunctorParser
                                                                                    sat_sg5D
                                                                                    top_reDS; } in
                                                                    let {
                                                                      sat_sg5A :: Int -> Int =
                                                                          \u []
                                                                              let {
                                                                                sat_sg5z :: Int =
                                                                                    CCCS I#! [0#];
                                                                              } in  const sat_sg5z;
                                                                    } in  local sat_sg5A sat_sg5E;
                                                                    };
                                                          } in  >>= $fMonadParser tm'_reDQ sat_sg5F;
                                                } in  >> $fMonadParser eq'_reDp sat_sg5G;
                                                }; } in
                                      let {
                                        sat_sg5t :: Parser Error Tm =
                                            \u []
                                                let {
                                                  sat_sg5s :: Parser Error () =
                                                      \u [] notFollowedBy colon_reDh eq_reDo;
                                                } in  *> $fApplicativeParser sat_sg5s tm'_reDQ;
                                      } in  uoptioned sat_sg5t sat_sg5H; } in
                            let {
                              sat_sg5r :: Int -> Int =
                                  \u [] let { sat_sg5q :: Int = CCCS I#! [1#]; } in  const sat_sg5q;
                            } in  local sat_sg5r sat_sg5I;
                            }; } in
                  let {
                    sat_sg5l :: Parser Error Span =
                        \u []
                            case pure $fApplicativeParser of k_sg58 {
                            __DEFAULT ->
                            let {
                              sat_sg5k :: Parser Error Span =
                                  \u []
                                      let {
                                        sat_sg5j :: () -> Span -> Parser Error Span =
                                            \r [ds_sg59 x_sg5a]
                                                case ds_sg59 of {
                                                () ->
                                                case x_sg5a of x1_sg5c {
                                                Span _ _ ->
                                                let {
                                                  sat_sg5i :: Parser Error Span =
                                                      \u []
                                                          let {
                                                            sat_sg5h :: Parser Error Span =
                                                                \u [] k_sg58 x1_sg5c;
                                                          } in  >> $fMonadParser ws sat_sg5h; } in
                                                let {
                                                  sat_sg5g :: Parser Error () =
                                                      \u []
                                                          let {
                                                            sat_sg5f :: Parser Error () =
                                                                \u [] isKeyword_reDs x1_sg5c;
                                                          } in  fails sat_sg5f;
                                                } in  >> $fMonadParser sat_sg5g sat_sg5i;
                                                };
                                                };
                                      } in  spanned scanIdent_reDt sat_sg5j;
                            } in  >> $fMonadParser lvl sat_sg5k;
                            };
                  } in  >>= $fMonadParser sat_sg5l sat_sg5J; } in
        let {
          sat_sg57 :: Parser Error () =
              \u []
                  let { sat_sg56 :: Int = CCCS I#! [0#]; } in  exactLvl sat_sg56;
        } in  >> $fMonadParser sat_sg57 sat_sg5K;

top_reDS :: Parser TopLevel = \u [] <|> sat_sg5L sat_sg5X;
end Rec }

src :: Parser TopLevel = \u [] *> $fApplicativeParser ws top_reDS;

parse :: ByteString -> Result Error TopLevel = \u [] runParser src;

parseFile :: String -> IO (ByteString, Result Error TopLevel) =
    \r [path_sg5Y]
        case path_sg5Y of path1_sg5Z {
        __DEFAULT ->
        let {
          sat_sg68 :: ByteString -> IO (ByteString, Result Error TopLevel) =
              \r [src1_sg61]
                  case src1_sg61 of src2_sg62 {
                  BS _ _ _ ->
                  case parse src2_sg62 of res_sg66 {
                  __DEFAULT ->
                  let {
                    sat_sg67 :: (ByteString, Result Error TopLevel) =
                        CCCS (,)! [src2_sg62 res_sg66];
                  } in  pure $fApplicativeIO sat_sg67;
                  };
                  }; } in
        let { sat_sg60 :: IO ByteString = \u [] readFile path1_sg5Z;
        } in  >>= $fMonadIO sat_sg60 sat_sg68;
        };

parseString :: String -> (ByteString, Result Error TopLevel) =
    \r [ds_sg69]
        case ds_sg69 of ds1_sg6a {
        __DEFAULT ->
        let { str_sg6b :: ByteString = \u [] packUTF8 ds1_sg6a; } in
        let { sat_sg6c :: Result Error TopLevel = \u [] parse str_sg6b;
        } in  (,) [str_sg6b sat_sg6c];
        };

SNil :: Spans = CCS_DONT_CARE SNil! [];

SCons :: Span %1 -> Spans %1 -> Spans =
    \r [eta_B0 eta_B1] SCons [eta_B0 eta_B1];

